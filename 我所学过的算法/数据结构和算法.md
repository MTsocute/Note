# 数据结构和算法

---

>  [!important]
>
>  这段代码为什么会有问题？
>
>  这段代码为什么会没有问题？
>
>  我是傻逼

<br>

## 1. 数学

---

### 1.1 牛顿求根公式

> 给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

- 对于这个题目，我们可以建立这样子一个恒等式关系，`x` 是我们要求的根用的值，那么我们要求的是 $\sqrt{x}$
- `x` 是变量，所以我们可以建立函数关系 $t = \sqrt{x}$，所以 `t` 就是我们要求的根
- 所以我们可以建立函数关系 $f(t) = t^2 - x = 0$
- 利用牛顿迭代法，我们可以建立一个新的关系 $t_1 = t_0 - \frac{f(t_0)}{f'(t_0)}$，迭代多次就行了
- $t_1 = t_0 - \frac{t_0^2 - x}{2t_0} \to t_n = t_{n-1} - \frac{t_{n-1}^2 - x}{2 t_{n-1}}$

```c++
class Solution {
public:
    constexpr double mySqrt(double x) {
        if (x == 0) return 0;
        double t0 = 10;	double X = x;
        return fabs(newtown(t0, X));
    }

    double newtown(double t0, double x) {
        double t1 = 0;
        while (1) {
            t1 = t0 - (t0 * t0 - x) / (2.0 * t0);
            if (fabs(t1 - t0) < 1e-7) break;
            t0 = t1;
        }
        return t1;
    }
};
```

> 这里补充两句，$t_0 > 0$ 我们分成两部分讨论
>
> 1. $t_0≠0$，这个是因为 $f'(t_0) ≠ 0$ 
> 2. $t_0 > 0$ 是因为我们求的是实数

<br>

## 2. 顺序存储

----

### 2.1 数组

#### 2.1.1 前缀和

```c++
class Solution {
private:
    // 第二个字存储前缀和出现的次数
    unordered_map<int, int> sum_i_minus_1;
    int times = 0;
public:
    Solution() {
        sum_i_minus_1[0] = 1;
    }
    int subarraySum(vector<int>& nums, int k) {
        int sum_0_toj = 0;
        for (const auto & x : nums) {
            sum_0_toj += x;
            // sum(0, i-1) =  sum(0,j)  - k
            int sum_i_minus_1_value = sum_0_toj - k;
            // 如果存在 sum(0, i-1) 这个区间，这个区间可能不止一个，所以考虑是加多次
            if (sum_i_minus_1.find(sum_i_minus_1_value) != sum_i_minus_1.end()) {
                times += sum_i_minus_1[sum_i_minus_1_value];
            }
            // 当前保存到哈希表，作为下一次的 sum(0, i-1)
            sum_i_minus_1[sum_0_toj] ++;
        }
        return times;
    }
};
```



### 2.2 矩阵

#### 2.2.1 分块遍历矩阵

> 实现的操作就是，按  `3x3` 的矩阵来遍历这个矩阵

![image-20241016170605614](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241016170605614.png)

> `i` 和 `j` 用来跳跃区间，而 `ii` 和 `jj` 才是对区间进行遍历

```c++
// block check 
/* find block */
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        unordered_map<char, bool> block_map;
        /* tranverse every block */
        for(int ii = i * 3; ii < (i*3 + 3); ii++) {
            for (int jj = j * 3; jj < (j*3 + 3); jj++) {
                if (board[ii][jj] == '.') continue;
                if (block_map[board[ii][jj]]) return false;
                block_map[board[ii][jj]] = true;
            }
        }
    }
}
```

<br>

## 3. 栈

---

### 3.1 逆波兰表达式生成器

```c++
// 中缀转后缀
void Calculate::infixToPostfix() {
    // pre_process the string
    pre_process(s);

    for (size_t i = 0; i < s.length(); ++i) {
        char current = s[i];
        // 不处理空格
        if (isspace(current)) continue;

        /* 处理数字
         * 如果是数字直接添加到后缀表达式
         * */
        if (isdigit(current)) {
            // 处理多位数
            while (i < s.length() && isdigit(s[i])) {
                posfix += s[i];
                i++;
            }
            posfix += ' ';  // 让多位数之间隔开，不然，譬如说：12 + 13 不隔开就会变成 1213 + 到时候后续没法处理的
            i--;     // 因为循环要结束，所以会多走一个，所以要减 1
        }
        /* 处理界限符
         * 如果是左括号，直接入栈，遇到 ) 就依次弹出运算符，直到 ( 运算符位置，注意 ) 不入栈
         * */
        else if (current == '(')
            operators.push(current);
        else if (current == ')') {
            while (operators.top() != '(') {
                posfix += operators.top();
                posfix += ' ';      // 隔开美观一点
                operators.pop();
            }
            operators.pop();    // 弹出 (
        }
        /* 处理操作符
         * 弹出当前栈顶优先级和自己同级或者高级的运算符，若碰到 ( 或 栈为空的时候。再入自己
         * */
        else {
            while (!operators.empty() && getPrecedence(operators.top()) >= getPrecedence(current)) {
                posfix += operators.top();
                posfix += ' ';      // 隔开美观一点
                operators.pop();
            }
            operators.push(current);    // 弹出了所有优先级和自己同级或更高级的运算符，改压入自己了
        }
    }

    // 处理剩余的运算符
    while (!operators.empty()) {
        posfix += operators.top();
        posfix += ' ';      // 隔开美观一点
        operators.pop();
    }
}
```

### 3.2 逆波兰表达式计算器

```c++
int Calculate::cal_posfix() {
    stack<int> values;
    string number;

    for (const auto &ch: posfix) {
        /* 处理遇到字符 */
        if (isdigit(ch)) number += ch;
        /* 遇到空格 */
        else if (isspace(ch)) {
            if (!number.empty()) {
                values.push(stoi(number));
                number.clear();
            }
        }
        /* 处理遇到运算符 */
        else {
            // 注意选取的顺序
            int b = values.top(); values.pop();
            int a = values.top(); values.pop();
            values.push(applyOperation(a, b, ch));
        }
    }
    return values.top();
}
```

> 大致框架

```c++
class Calculate {
public:
    Calculate(string infix) : s(infix) {};
    int getPrecedence(char op);
    int applyOperation(int a, int b, char op);
    void pre_process(string &infix);
    void infixToPostfix();
    int cal_posfix();
    void show_posfix() const { cout << posfix << endl; }
private:
    string s;
    string posfix;  // transform s to posfix
    stack<char> operators;
};

// 函数用于获取操作符的优先级
int Calculate::getPrecedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// 函数用于执行基本的算术操作
int Calculate::applyOperation(int a, int b, char op) {
    switch (op) {
        case '+':
            return a + b;
        case '-':
            return a - b;
        case '*':
            return a * b;
        case '/':
            return a / b;
    }
    return 0;
}

// 对字符串进行一个预处理
void Calculate::pre_process(std::string &infix) {
    // 删除所有的空格
    infix.erase(remove_if(infix.begin(), infix.end(), ::isspace), infix.end());
    if (infix[0] == '-') infix.insert(0, 1, '0');

    // 处理 (- 的情况
    string target = "(-";
    string replacer = "(0-";

    // 找到所有的 (- 的位置，并从这个位置开始替换
    while (infix.find(target) != string::npos) {
        // replace usage: string.replace(pos, len, replacer)
        infix.replace(infix.find(target), target.length(), replacer);
    }
}

int main() {
    Calculate ca(s);
    ca.infixToPostfix();
    return ca.cal_posfix();
}
```



## 4. 串

---

#### 4.1 KMP 算法

```c++

```



#### 4.2 KMP 数组的构建

```c++

```



## 5. 树

---

### 5.1 二叉树

#### 5.1.1 利用前序和中序构建二叉树

```c++
using my_map = unordered_map<int, int>;

class Solution {
private:
    // 构造哈希映射，帮助我们快速定位根节点
    my_map index;

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // 构建数和对应的 index
        for (int i = 0; i < inorder.size(); ++i)
            index[inorder[i]] = i;
        return helper(preorder, 0, preorder.size()-1, 0, inorder.size()-1);
    }

    TreeNode * helper(vector<int> & preorder, int pre_left , int pre_right, int in_left, int in_right) {
            // 递归的停止
            if (pre_left > pre_right || in_left > in_right) return nullptr;

            // 前序遍历的第一个节点就是树的根节点
            auto root_val = preorder[pre_left];
            // 利用 hash 快速定位其在 inorder 的 index
            auto in_root = index[root_val];
            // 知道了中序根节点的 index 我们就可以进一步的划分区间，然后把每一个根节点按左中右组合起来
            auto * root = new TreeNode(root_val);

            // 左子树：pre_left+1 到 pre_left + (in_root - in_left)
            root->left = helper(preorder, pre_left+1, pre_left + (in_root - in_left), 
                                in_left, in_root-1);

            // 右子树：pre_left + (in_root - in_left) + 1 到 pre_right
            root->right = helper(preorder, pre_left + (in_root - in_left) + 1, pre_right, 
                                 in_root+1, in_right);

            return root;
    }   
};
```

#### 5.1.2 利用后序和中序构建二叉树

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012204722143.png" alt="image-20241012204722143" style="zoom:40%;" />

```c++
using my_map = unordered_map<int, int>;

class Solution {
private:
    my_map in_index;

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); i++)
            in_index[inorder[i]] = i;

        return helper(postorder, 0, inorder.size()-1, 0, postorder.size()-1);
    }

    TreeNode *helper(vector<int>& postorder, int in_left, int in_right, int pos_left, int pos_right) {
        if (in_left > in_right || pos_left > pos_right) return nullptr;

        int in_root = in_index[postorder[pos_right]];
        auto * root = new TreeNode(postorder[pos_right]);
        int len = in_root - in_left;

        // in 和 pos 左区间
        root->left = helper(postorder, in_left, in_root-1, pos_left, pos_left+len-1);
        // in 和 pos 右区间
        root->right = helper(postorder, in_root+1, in_right, pos_left + len, pos_right-1);

        return root;
    }
};
```

#### 5.1.3 二叉树遍历显式栈写法

> 中序遍历

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
private:
    vector<int> res;
    stack<TreeNode*> stk;
};
```

> 后序遍历

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        while(root != nullptr or !s.empty()) {
            while(root != nullptr) {
                s.push(root);
                nodeList.push_back(root->val);
                root = root->left;
            }
            root = s.top();
            s.pop();
            root = root->right;
        }
        return nodeList;
    }
private:
    stack<TreeNode* > s;
    vector<int> nodeList;
};
```

### ==5.2 后序遍历的从下往上思想==

> 对于一个树来说，一个节点我们经过它实际上是两次，第一次是遍历到它，第二次是回溯经过它
>
> **所以很多自下而上的操作，就是在回溯的时候处理的**
>
> 当然也有回溯的到当前层次的时候，取消当前层影响的操作，但是那个大多数时候的结构应该算是树

- [最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)
- [一个树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/)

<br>

## 6. 图

---

### 6.1 邻接表和矩阵

> 顶点数组后面跟的全部都是弧节点，用于连立前后关系

```c++
// 邻接表中的边节点
struct ArcNode {
    int weight;		// 
    int adjacent_vertex_index;  // 邻接顶点的索引
    ArcNode *next;  // 指向下一个邻接点
};

// 邻接表图中的顶点
struct VertexNode {
    char data;  // 顶点信息
    ArcNode *first_edge;  // 邻接表中的第一个边节点
};

// 邻接表图
struct ALGraph {
    VertexNode adj_list[MAX_SIZE];  // 邻接表
    int vertex_count;  // 顶点数量
    int edge_count;  // 边的数量
};
```

#### 6.1.1 邻接表和邻接矩阵的缺点

![image-20241005115947165](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005115947165.png)

### 6.2 图的遍历

---

#### 6.2.1 DFS

> 邻接表

```c++
// 邻接表的深度优先搜索
void DFS_ALGraph(ALGraph *alg, int start_vertex, vector<bool> &visited) {
    visited[start_vertex] = true;
    cout << alg->adj_list[start_vertex].data << " ";

    ArcNode *edge = alg->adj_list[start_vertex].first_edge;
    while (edge != nullptr) {
        if (!visited[edge->adjacent_vertex_index]) {
            DFS_ALGraph(alg, edge->adjacent_vertex_index, visited);
        }
        edge = edge->next;
    }
}
```

> 邻接矩阵

```c++
// 邻接矩阵的深度优先搜索
void DFS_MGraph(MGraph *mg, int start_vertex, vector<bool> &visited) {
    visited[start_vertex] = true;
    cout << mg->vertices[start_vertex] << " ";

    for (int i = 0; i < mg->vertex_count; i++) {
        if (!visited[i] && mg->edges[start_vertex][i] == 1) {
            DFS_MGraph(mg, i, visited);
        }
    }
}
```

#### 6.2.2 BFS

> 邻接表

```c++
void BFS_ALGraph(ALGraph *ag, int start_index) {
    vector<bool> visited(ag->vexnum, false);  // 记录是否访问过
    queue<int> q;  // BFS 使用的队列
    visited[start_index] = true;  // 标记起点
    q.push(start_index);

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << ag->adjList[current].data << " ";  // 输出当前节点

        // 遍历当前节点的所有邻接节点
        ArcNode *adj_node = ag->adjList[current].first;
        while (adj_node != nullptr) {
            int adj_index = adj_node->adjvex_index;
            if (!visited[adj_index]) {  // 如果未访问
                visited[adj_index] = true;
                q.push(adj_index);
            }
            adj_node = adj_node->next;
        }
    }
}
```

> 邻接矩阵

```c++
void BFS_MGraph(MGraph *mg, int start_index) {
    vector<bool> visited(mg->vexnum, false);  // 记录是否访问过
    queue<int> q;  // BFS 使用的队列
    visited[start_index] = true;  // 标记起点
    q.push(start_index);

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << mg->vex[current] << " ";  // 输出当前节点

        // 遍历所有邻接的节点
        for (int i = 0; i < mg->vexnum; i++) {
            if (mg->edge[current][i] == 1 && !visited[i]) {  // 如果有边且未访问
                visited[i] = true;
                q.push(i);
            }
        }
    }
}
```



### 6.3 十字链表和邻接多重表

---

#### 6.3.1 十字链表

> 存储有向图
>
> **大致构成**

![image-20241005163619053](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005163619053.png)

> **大致结构**

- 和邻接表有点像，顶点节点为一个数组

- 一个节点有两个指针

	1. 左边的指针代表着，谁指向自己

	2. 右边的指针代表着，自己指向谁
	3. 用 A 为案例，我们知道 $A \to B$、$A \to C$、$D \to A$、$C \to A$
	4. 那么仔细看，通过节点数组，我们可以用 A 橙色的部分找到所有的入度，绿色部分找到素有的出度

- 节点的两个指针指向的是一个弧类型，弧左右的编号代表两节点，关系还得看是左指针还是右指针

![image-20241005171325118](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005171325118.png)

#### 6.3.2 邻接多重表

> 用于存储无向图
>
> 传统的邻接表，有一个大问题就是，如果要删除一个节点，这个节点如果牵涉到很多其他的节点的话
>
> 删除是非常麻烦的，基本是从数组的每一个节点开始遍历，再遍历每一个链表

![image-20241005193706006](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005193706006.png)

> 大体结构
>
> **对于有重复的关系，我们都用同一个弧节点**

![image-20241005194118444](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005194118444.png)

### 6.4 最短路径

---

![image-20241005235517140](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241005235517140.png)

#### 6.4.1 BFS Distance 表

![image-20241006132405726](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006132405726.png)

> 这里需要知道表的性质

![image-20241006132456793](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006132456793.png)

#### 6.4.2 BFS 最短路径

> 辅助的输出内容的函数

```c++
static void min_distance_display(MGraph &mg, const int &start_vertex, const vector<vector<int>> &distances) {
    cout << "Begin With Index: " << start_vertex << endl;
    cout << "TO : ";
    for (int i = 0; i < mg.vertex_count; i++) cout << setw(5) << i << " ";
    cout << endl;

    // 输出 distance 里面的数据
    cout << "Dis: ";
    for (int i = 0; i < mg.vertex_count; i++) {
        if (distances[0][i] == INFIN) {
            // inf 代表 start_vertex 没办法到这个顶点
            cout << setw(5) << "inf" << " ";
        } else {
            cout << setw(5) << distances[0][i] << " ";
        }
    }
    cout << endl;

    cout << "Pre: ";
    for (int i = 0; i < mg.vertex_count; i++) {
        cout << setw(5) << distances[1][i] << " ";
    }
    cout << endl;
}
```

> 这里我们简述一下 `distances` 表的作用
>
> `Begin With Index`：表示你从那个节点开始出发
>
> `TO`：去往哪个节点
>
> `Dis`：到达对应的节点之间的距离（BFS weight 默认为 1）
>
> `Pre`：到达这个节点的前一个节点，**可以一直追溯到出发节点**，譬如说 $0 \to2$ 顶点，那么从 2 看，就是一直找 `pre`：$1 \to 0 \to -1$，-1 对应的 Index 就是 0

```shell
Begin With Index: 0
TO :     0     1     2     3     4     5     6     7 
Dis:     0     1     2     1   inf   inf   inf   inf 
Pre:    -1     0     1     0    -1    -1    -1    -1 
```



> 实现的逻辑

```c++
// BFS 实现最短路径
// 从指定节点开始到其他的节点的最短路径，默认 weight 是 1
void BFS_Min_Distance(MGraph &mg, const int start_vertex) {
    vector<bool> visited(mg.vertex_count, false);
    queue<int> q;

    // 初始化 distance
    // d[0] 代表路径之间的 weight (默认为 1)
    // d[1] 通往顶点的 index
    vector<vector<int>> distances(2, vector<int>(mg.vertex_count, 0));
    for (int i = 0; i < mg.vertex_count; i++) distances[1][i] = -1;
    
    distances[0][start_vertex] = 0; // 自己访问自己，之间的距离自然是 0
    visited[start_vertex] = true;
    q.push(start_vertex);

    while (!q.empty()) {
        int cur = q.front();
        q.pop();

        for (int i = 0; i < mg.vertex_count; i++) {
            if (mg.edges[cur][i] != 0 && !visited[i]) { // 假设权重为 1
                distances[0][i] = distances[0][cur] + 1; // 更新距离
                distances[1][i] = cur; // 更新前驱
                q.push(i); 
                visited[i] = true;
            }
        }
    }

    // 输出 distances 内容 (上面的辅助函数)
    min_distance_display(mg, start_vertex, distances);
}
```



#### ==6.4.3 Dijistra==

> 解决了有向相当于解决了无项最短路径问题

![image-20241006141746680](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006141746680.png)

> 因为对于无向，来去的 weight 是一样大的，所以当一个线路就行

![image-20241006144032896](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006144032896.png)

> 辅助用的表和 `BFS Distance` 差不多的
>
> [可以参考这个流程顺序](https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)，来了解整个的运行逻辑

##### 6.4.3.1 Dijistra 的初始化工作

> 这里我们假定从 $v_0$ 开始，那么初始化应该是达到右边表的效果

![image-20241006144203604](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006144203604.png)

```c++
// ALGraph 的 Dijkstra 算法
void Dijkstra_Min_Distance(ALGraph &alg, const int start) {
    // 三个表初始化
    vector<bool> visited(alg.vertex_count, false);
    vector<vector<int>> distances(2, vector<int>(alg.vertex_count, INFIN));
    distances[1] = vector<int>(alg.vertex_count, -1); // 前驱初始化为 -1

    distances[0][start] = 0;  // 起点到自己的距离为 0
    visited[start] = true;	  // 访问过自己了
    

    // 第一个开始节点的邻边全部写入到 distances 里面
    auto p_cur = alg.adj_list[start].first_edge;
    while (p_cur != nullptr) {
        int adj_index = p_cur->adjacent_vertex_index;
        distances[0][adj_index] = p_cur->weight;  // 更新相邻节点的距离
        distances[1][adj_index] = start;          // 设置前驱为 start
        p_cur = p_cur->next;
    }
        
    // ...
}
```

##### 6.4.3.2 从第一个点出发之后的工作

> 接下来呢，初始化之后的表，我们应该找到开始节点最小的邻边

![image-20241006162709737](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006162709737.png)

```c++
    // 记录最小的邻边 (用一个顶点更新了所有的邻边之后)
    int min_distance = INFIN;
    int min_vertex = -1;

    for (int j = 0; j < alg.vertex_count; ++j) {
        // 初始化一结束，找最小的对应的条件就是：1、没访问过；2、weight 最小
        if (!visited[j] && distances[0][j] < min_distance) {
            min_distance = distances[0][j];
            min_vertex = j;
        }
    }

    // 如果找不到最短路径节点，则结束 --> 所有的节点都 visited 了，所以不需要
    if (min_vertex == -1) break;

    // 标记该节点为已访问
    visited[min_vertex] = true;
    
    // ...
```

> 找到最小的邻边节点之后，那么我们从它出发并关注它对应的邻接顶点
>
> 所以我们需要遍历 `min_vertex` 全部的邻边

![image-20241006162750591](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006162750591.png)

```c++
		// 找到 min_vertex 的全部邻边
        auto edge = alg.adj_list[min_vertex].first_edge;
        while (edge != nullptr) {
            int neighbor = edge->adjacent_vertex_index;	// 每一次邻边对应的 index
			// ...
            edge = edge->next;	// 便利完 min_vertex 的所有邻边
        }
    }
```

> 让我们来更新 `min_vertex` 邻边所有的数据
>
> 我们的根源是 $v_0$，现在是 $v_0 \to v_4$，你会发现如果从 $v_4 \to v_1$，这里相当于 $v_0$ 再一次的遇到了 $v_1$
>
> 因为一开始从 $v_0$ 出发的时候，$v_1$ 就是 $v_0$ 的邻边，所以 dist 一开始 是 10
>
> 但是你惊奇的发现 $v_0 \to v_4 \to v_1$ 这个线路居然才只有 8，所以我们找到了一个更短的路径，修改值
>
> 同理处理其他的邻边，得右表：

![image-20241006163625894](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006163625894.png)

```c++
      	// min_vertex 的邻边遍历
        auto edge = alg.adj_list[min_vertex].first_edge;
        while (edge != nullptr) {
            // 邻边的具体 index
            int neighbor = edge->adjacent_vertex_index;
            // 可能会遇到之前的边，
            if (!visited[neighbor] && 
                distances[0][min_vertex] + edge->weight < distances[0][neighbor]) 
            {
                distances[0][neighbor] = distances[0][min_vertex] + edge->weight;
                distances[1][neighbor] = min_vertex;  // 更新前驱
            }
            edge = edge->next;
        }
    }
```

> 然后我们从没有标记为最小路径的 `visied` 中选一个没有标记的，选一个最小路径，作为下一次的 `min_verterx` ，这里就是循环的开始

![image-20241006170105107](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006170105107.png)

> 所以循环的开始就是 **找最小边** 这里开始，所以循环应该为：

```c++
// ALGraph 的 Dijkstra 算法
void Dijkstra_Min_Distance(ALGraph &alg, const int start) {
	// 初始化三个表
    // start 节点的表初始化完成
    
    // 除去开头的 start，那么应该遍历 顶点个数 - 1 次数
    for (int i = 0; i < alg.vertex_count-1; ++i) {
        // 找到最小距离的边，并标记为 true
        // 访问最小邻接顶点的所有边，如果其到新的顶点的路径比之前还要小的话，更新
    }
}
```

##### 6.4.3.3 完整代码

```c++
void Dijkstra_Min_Distance(ALGraph &alg, const int start) {
    // 三个表初始化
    vector<bool> visited(alg.vertex_count, false);
    vector<vector<int>> distances(2, vector<int>(alg.vertex_count, INFIN));
    distances[1] = vector<int>(alg.vertex_count, -1); // 前驱初始化为 -1

    visited[start] = true;    // 标记 start 为已访问
    distances[0][start] = 0;  // 起点到自己的距离为0

    // 处理起始节点的邻边
    auto p_cur = alg.adj_list[start].first_edge;
    while (p_cur != nullptr) {
        int adj_index = p_cur->adjacent_vertex_index;
        distances[0][adj_index] = p_cur->weight;  // 更新相邻节点的距离
        distances[1][adj_index] = start;          // 设置前驱为 start
        p_cur = p_cur->next;
    }

    // 处理剩余节点
    for (int i = 0; i < alg.vertex_count-1; ++i) {
        // 找到未访问节点中距离最近的节点
        int min_distance = INFIN;
        int min_vertex = -1;

        for (int j = 0; j < alg.vertex_count; ++j) {
            // 找最小的两个条件，不能是最短路径的，而且要是最小的
            if (!visited[j] && distances[0][j] < min_distance) {
                min_distance = distances[0][j];
                min_vertex = j;
            }
        }

        // 如果找不到最短路径节点，则结束
        if (min_vertex == -1) break;

        // 标记该节点为已访问
        visited[min_vertex] = true;

        // 更新相邻节点的距离
        auto edge = alg.adj_list[min_vertex].first_edge;
        while (edge != nullptr) {
            int neighbor = edge->adjacent_vertex_index;
            if (!visited[neighbor] && 
                distances[0][min_vertex] + edge->weight < distances[0][neighbor]) 
            {
                distances[0][neighbor] = distances[0][min_vertex] + edge->weight;
                distances[1][neighbor] = min_vertex;  // 更新前驱
            }
            edge = edge->next;
        }
    }

    // 输出距离和前驱
    min_distance_display(alg, start, distances);
}
```

##### 6.4.3.4 利用 priority_queue 优化

> 邻接表

```c++
// ALGraph 的 Dijistra
void Dijkstra_Min_Distance(ALGraph &alg, const int start) {
    // 三个表初始化
    vector<bool> visited(alg.vertex_count, false);
    vector<vector<int>> distances(2, vector<int>(alg.vertex_count, INFIN));
    distances[1] = vector<int>(alg.vertex_count, -1); // 前驱初始化为 -1

    distances[0][start] = 0; // 起点到自己的距离为 0
    // 优先队列，存储（距离，顶点索引）
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start}); // 初始将起点加入队列

    while (!pq.empty()) {
        // 找最小操作简化成 top
        auto [min_distances, min_index] = pq.top();
        pq.pop();

        if (min_index == -1) break;
        visited[min_index] = true;

        auto edge = alg.adj_list[min_index].first_edge;
        while (edge != nullptr) {
            int neighbor = edge->adjacent_vertex_index;
            if (!visited[neighbor] &&
                distances[0][min_index] + edge->weight < distances[0][neighbor])
            {
                distances[0][neighbor] = distances[0][min_index] + edge->weight;
                distances[1][neighbor] = min_index; // 更新前驱
                // 把哪些更新了的塞入 pq
                pq.push({distances[0][neighbor], neighbor});
            }
            edge = edge->next;
        }
    }

    // 输出距离和前驱
    min_distance_display(alg, start, distances);
}
```

> 邻接矩阵

```c++
void Dijistra_Min_Distance(MGraph & mg, const int start) {
    // 三个表初始化
    vector<bool> visited(mg.vertex_count, false);
    vector<vector<int>> distances(2, vector<int>(mg.vertex_count, INFIN));
    distances[1] = vector<int>(mg.vertex_count, -1); // 前驱初始化为 -1

    distances[0][start] = 0; // 起点到自己的距离为 0
    // 最小堆，第一个存储 distance，第二个存储 index
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    // 塞入第一个节点
    pq.push({0, start});

    while (!pq.empty()) {
        auto [min_distance, min_index] = pq.top();
        pq.pop();

        if (visited[min_index]) continue; // 一开始就找不到最小的，直接返回了
        // 没有退，就会找到对应的最小顶点位置
        visited[min_index] = true;

        for (int i = 0; i < mg.vertex_count; i++) {
            // 找邻边，然后比新长
            if (mg.edges[min_index][i] != 0 and 
                distances[0][i] > distances[0][min_index] + mg.edges[min_index][i]) 
            {   
                distances[0][i] = distances[0][min_index] + mg.edges[min_index][i];
                distances[1][i] = min_index;
                pq.push({distances[0][i], i});
            }
        }
    }

    min_distance_display(mg, start, distances);
}
```

#### 6.4.4 Floyd

> 只用于邻接矩阵，本质上是动态规划问题
>
> `A` 左上角的 `k` 的意思是允不允许再这个点发生中转

##### 6.4.4.1 大致结构和思路

> 假定要在 $k = 0$ 这里发生中转

![image-20241006222805627](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006222805627.png) 

> 那么我们原先 $v_2 \to v_1$ 是没有路径的，但是因为 $v_0$ 可以作为中转之后，就有一条：
>
> $A^{(-1)}[2][0]$：$v_2\to v_0$
>
> $A^{(-1)}[0][1]$：$v_0 \to v_1$
>
> $-1$ 的意思是允许在 0 这里发生中转 $(0-1)$，而且这条路径还比原本的 $v_2 \to v1$ 要短

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006222934280.png" alt="image-20241006222934280" style="zoom:60%;" />

> 找了一个比原本线路还要短的情况的时候，我们要更新两个东西
>
> 更新 $v_2 \to v1$ 为更短的路径 11
>
> 更新两个点之间更新为中转点
>
> 所以 `Floyd` 的整体就是一个三重循环，只需要一个基本逻辑就找到所有节点之间的最短路径

![最终结果](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006225349308.png)

##### 6.4.4.2 基本逻辑

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241006222556312.png" alt="image-20241006222556312" style="zoom:77%;" />

> 邻接表

```c++
void Floyd_Min_Distance(ALGraph & alg) {
    vector<vector<int>> distance (alg.vertex_count, vector<int> (alg.vertex_count, INFIN));
    vector<vector<int>> pre (alg.vertex_count, vector<int> (alg.vertex_count, -1));

    // 转换 Alg 为矩阵
    for (int i = 0; i < alg.vertex_count; i++) {
        auto cur = alg.adj_list[i].first_edge;
        distance[i][i] = 0;		// 自己到自己的距离为 0
        while (cur != nullptr) {
            distance[i][cur->adjacent_vertex_index] = cur->weight;
            cur = cur->next;
        }
    }

    for (int k = 0; k < alg.vertex_count; k++) {
        for (int i = 0; i < alg.vertex_count; i ++) {
            for (int j = 0; j < alg.vertex_count; j++) {
                if (distance[i][j] > distance[i][k] + distance[k][j]) {
                    distance[i][j] = distance[i][k] + distance[k][j];
                    pre[i][j] = k;
                }
            }
        }
    }
}
```

> 邻接矩阵

```c++
// MGraph 的 Floyd 
void Floyd_Min_Distance(MGraph & mg) {
    // 前区表
    vector<vector<int>> distance(mg.vertex_count, vector<int>(mg.vertex_count));
    vector<vector<int>> pre(mg.vertex_count, vector<int> (mg.vertex_count, -1));

    // 拷贝 MGraph 的内容
    for (int i = 0; i < mg.vertex_count; i++) {
        distance[i] = vector<int> (mg.edges[i], mg.edges[i] + mg.vertex_count);
    }

    for (int k = 0; k < mg.vertex_count; k++) {
        for (int i = 0; i < mg.vertex_count; i ++) {
            for (int j = 0; j < mg.vertex_count; j++) {
                if (distance[i][j] > distance[i][k] + distance[k][j]) {
                    distance[i][j] = distance[i][k] + distance[k][j];
                    pre[i][j] = k;
                }
            }
        }
    }
}
```

> 辅助用输出函数

```c++
// 输出距离和前驱表
cout << "Distance Matrix:\n";
for (const auto &row : distance) {
    for (int d : row) {
        if (d == INFIN) cout << setw(5) << "inf" << " ";
        else cout << setw(5) << d << " ";
    }
    cout << endl;
}

cout << "Predecessor Matrix:\n";
for (const auto &row : pre) {
    for (int p : row) {
        cout << setw(5) << p << " ";
    }
    cout << endl;
}
```



### 6.5 最小生成树

---

> [视频讲解](https://www.youtube.com/watch?v=qsKvb6zFK-A&list=PLY_ztJBSZw7h2No3dSMW2d0mDuuv5xSPX&index=65)

![image-20241007125235920](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007125235920.png)

![image-20241007125752137](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007125752137.png)

#### 6.5.1 Prim 算法

> 对于这样子的结构，他的实现逻辑和最短路径中的 `Dijistra` 算法差不多都是在找最小邻边，然后更新对应的邻接点
>
> 唯一不一样的是**，`Dijistra` 考虑的是累积和是不是比之前的小，而 `Prim` 考虑的是单次到达那边更小就行**
>
> 这个根本区别的原因是，`Dijistra` 考虑的是一个点到其他点的最小距离，而 `Prim` 用于找到一个无向图的最小生成树，即连接所有顶点的边的集合，使得边的总权重最小

![image-20241007125851335](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007125851335.png)

#### 6.5.2 初始化逻辑

![image-20241007131227236](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007131227236.png)

![image-20241007133122445](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007133122445.png)

> 邻接表

```c++
// ALGraph 的 Prim Mini Tree (和 Dijistra 简直如出一辙)
void MST_Prim(const ALGraph & alg, const int start) {
    // 1. 第一层记录权值
    // 2. 第二层记录父亲节点的 index
    vector<vector<int>> dis(2, vector<int> (alg.vertex_count, INFIN));
    vector<bool> visited(alg.vertex_count, false);  // 找到的新的节点是不是已经加入了树
    dis[1] = vector<int> (alg.vertex_count, -1);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    // 自己到自己 0 
    dis[0][start] = 0;
    pq.push({0, start});    // 我们默认从 0 顶点开始


    while (!pq.empty()) {
        auto [low_cost, low_cost_index] = pq.top();
        pq.pop(); 

        // 防止加入树的节点
        if (visited[low_cost_index]) continue;
        visited[low_cost_index] = true;

        auto cur_p = alg.adj_list[low_cost_index].first_edge;
        
        // 更新邻边，并加入到最小堆中
        while (cur_p != nullptr) {
            int neighbor = cur_p->adjacent_vertex_index;
            // 特别注意这个判断条件，和 Dijistra 最大区别就是累积比较和单值比较
            if (!visited[neighbor]and dis[0][neighbor] > cur_p->weight) {
                dis[0][neighbor] = cur_p->weight;
                dis[1][neighbor] = low_cost_index;
                pq.push({dis[0][neighbor], neighbor});
            }
            cur_p = cur_p->next;
        }
    }

    cout << "Mini-Spaining Tree: \n";
    cout << "Minimum Spanning Tree Edges:\n";
    for (int i = 1; i < alg.vertex_count; i++) { // 从1开始，0是起点
        if (dis[1][i] != -1) { // 只输出有父节点的
            cout << "Edge: " << dis[1][i] << " -- " << i 
                << " with weight " << dis[0][i] << endl;
        }
    }
    // 辅助输出函数
    min_distance_display(alg, start, dis);
}
```

### 6.6 AOV 拓扑排序

---

> 拓扑排序是不可以存在回路的

![image-20241007140339989](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007140339989.png)

> 不存在拓扑排序的情况

![image-20241007140553617](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007140553617.png)

> 代码的逻辑

![image-20241007140709263](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241007140709263.png)

```c++
void TopoSort(const ALGraph &alg) {
    vector<int> indegree = calculate_indegree(alg); // 计算入度
    queue<int> q;
    vector<char> topo_order; // 存储拓扑排序结果
    int count  = 0; // 防止回路

    // 将所有入度为 0 的顶点入队
    for (int i = 0; i < alg.vertex_count; i++)
        if (indegree[i] == 0) q.push(i);

    // 读取所有的 0 入度节点，并且删除链接的点
    while (!q.empty()) {
        int cur_index = q.front(); q.pop();
        topo_order.push_back(alg.adj_list[cur_index].data);
        count ++;
        auto cur_node = alg.adj_list[cur_index].first_edge;
        while (cur_node != nullptr) {
            int neightbor = cur_node->adjacent_vertex_index;
            indegree[neightbor]--;
            if (indegree[neightbor] == 0) q.push(neightbor);
            cur_node = cur_node->next;
        }
    }

    if (count < alg.vertex_count) std::cout << "Looping\n";
    else {
        cout << "Topo Sort Result: \n";
        for (const auto & topo: topo_order)
            cout << topo << " ";
        cout << endl;
    }
}
```

<br>

## 7. 查找

---

### 7.1 二叉平衡树

---

> 最关键的问题就是，==最小不平衡子树==
>
> 譬如说这个 `RR` ，是从 70 这里开始不平衡的

![image-20241008161526842](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241008161526842.png)

> 再看这边的 `RR` 问题，我们知道这个是不平衡的，那么就从 90 往上面走，一直找到不平衡的位置，刚好不平衡的地方就是最小不平衡子树

![image-20241008161628657](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241008161628657.png)

> 既下图

![image-20241008161851123](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241008161851123.png)

### 7.2 二叉搜索树

---

#### 8.1 升序数组构造二叉平衡树

> 平衡二叉树并不是最好的树，所以为了实现之间的转换还得构造 AVL，那么如果真的要手撕代码量非常的大，所以建议，**转换成升序数组然后再去构建二叉平衡树**，这样子在一定程度上至少减少记忆量，能随手写出来有些时候更加重要

我们可以通过中序遍历将原来的二叉搜索树转化为一个有序序列，然后对这个有序序列递归建树，对于区间 $[L,R]$：

- 取 $mid= [\frac{L+R}{2} ]$ ，即中心位置作为当前节点的值；

- 如果 $L≤mid−1$，那么递归地将区间 $[L,mid−1]$ 作为当前节点的左子树

- 如果 $mid+1≤R$，那么递归地将区间 $[mid+1,R]$ 作为当前节点的右子树

> 之类的范围是  $[L,R]$，所以 $right = nums.size() - 1$

```c++
TreeNode* sortedArrayToBST(vector<int>& nums, int left, int right) {
    if (left > right) return nullptr;

    // 选择任意一个中间位置数字作为根节点
    int mid = (right - left) / 2 + left;

    TreeNode* root = new TreeNode(nums[mid]);
    root->left = helper(nums, left, mid - 1);
    root->right = helper(nums, mid + 1, right);
    return root;
}
```

#### 8.2 AVL 的删除

> [删除的操作介绍](https://www.youtube.com/watch?v=gWKOQVx05w4&list=PLY_ztJBSZw7h2No3dSMW2d0mDuuv5xSPX&index=72)

![image-20241009155800494](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241009155800494.png)

> 最高的儿子、孙子的说法就是从最小不平衡子树作为根的树，从底层到上面根作为距离测算
>
> 譬如说，最下面的那个 85 95 都是底层，他们高度算 一，然后上面走 90 算二，80 算 三，而 77 只能算 一
>
> 所以最高的儿子是 80

![image-20241009155726033](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241009155726033.png)

> 根据孙儿的顺序，依次确定孙在儿子的那里，儿子在根的那里，来确定最后是什么类型的旋转
>
> 譬如说这里是孙子在儿子的右边，所以是 `R`，然后儿子在根的右边，所以是 `R`
>
> **最后根据从如何到孙子的顺序，来确定字母，来确定孙子旋转的过程**
>
> 所以是 `RR` 的旋转

![image-20241009155937936](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241009155937936.png)

![image-20241009160015418](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241009160015418.png)

> 这个案例是 `RL`，到儿子是 R 到孙子是 L 

![image-20241010173901593](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010173901593.png)

#### 8.3 AVL 删除但不是叶子节点

![image-20241010174347402](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010174347402.png)

> 用前继的话，就是找左子树的最右下节点，那个值是左子树中最大的
>
> 用后继的话，就是右子树的最左下角，那个是有子树最小的

![image-20241010174544001](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010174544001.png)

![image-20241010174611763](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010174611763.png)

> 到这里之后，我们后面的操作就和 AVL 删除是一样的了

![image-20241010174735810](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010174735810.png)

#### 8.4 AVL 叶子节点一个注意事项

> `AVL`：任意子树部分都需要满足高度差是 1，所以哪怕是删除了，虽然根节点是平衡的，但是也不能算是平衡

![image-20241010175212087](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241010175212087.png)

<br>

### 7.3 红黑树

---

#### 9.1 红黑树的性质

> [参照视频学习效果更好](https://www.bilibili.com/video/BV1Xm421x7Lg/?spm_id_from=333.788&vd_source=b47817c1aa0db593f452034d53d4273a)
>
> 口诀：左根右，根叶黑，不红红，黑路同

![image-20241009140358348](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241009140358348.png)

#### 9.2 红黑树的构建

> 插入满足一个性质：插入的节点一定是**红色**
>
> 因为如果插入的颜色是红色的话，可能和性质出入的地方，只有根、不能连续红色
>
> 对于违背性质的地方，我们可以水用下面的方法来做调节

<img src="/Users/momo/Library/Application Support/typora-user-images/image-20241011161501138.png" alt="image-20241011161501138" style="zoom:77%;" />

> 对于叔叔和父亲还有爷爷的关系的解释图
>
> `cur` 是刚插入的节点

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011161749769.png" alt="image-20241011161749769" style="zoom:67%;" />

> 对于后面两个叔叔节点的我们要细节说明一些

##### 9.2.1 叔叔是红色

> 叔叔也节点是红色，那么我们吧叔叔父亲爷爷变换颜色之后，有些时候，可能还违背性质所以我们需要进一步操作

- 刚刚插入了一个红色的节点，因为出现了连续的红色，但是其叔叔节点 `17` 是红色的，所以上面三个元素都要变色

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011162228758.png" alt="image-20241011162228758" style="zoom:50%;" />

> 这个时候根变成了红色违背了性质，所以我们利用第一个方法，转黑

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011162326274.png" alt="image-20241011162326274" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011162458978.png" alt="image-20241011162458978" style="zoom:60%;" />

<br>

##### 9.2.2 叔叔是黑色

- 这个时候刚刚插入了一个 `27`，但是叔叔是黑色的，所以我们要根据父亲和儿子所在的位置，按顺序看下来，确定字母
- 譬如说 `34` 是 23 的儿子，27 是 23 的孙子，那么按顺序过去就是 `RL` 

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011162645907.png" alt="image-20241011162645907" style="zoom:60%;" />

#### ==9.3 红黑树的删除==

![image-20241013215015548](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013215015548.png)

##### 9.3.1 只有左右孩子

> **这个只会有一黑一红的情况，红色要么在左边，要么在右边**，证明看[这里](https://www.bilibili.com/video/BV16m421u7Tb/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)的 2:27
>
> 删除的对象是 10
>
> 父节点和子红色节点连接，然后改变颜色

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011224656000.png" alt="image-20241011224656000" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241011224824621.png" alt="image-20241011224824621" style="zoom:67%;" />

##### 9.3.2 没有孩子

> 没有孩子要分成两个情况

###### 9.3.1 节点是红色

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012203247715.png" alt="image-20241012203247715" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012203259969.png" alt="image-20241012203259969" style="zoom:50%;" />

###### ==9.3.2 节点是黑色==

> 过于困难，所以单独拿出来
>
> 对于没有孩子的黑色节点的删除，还需要考虑其兄弟的颜色



- 兄弟是黑色
- **兄弟至少有一个红色孩子**：（LL、RR、LR、RL）变色 + 旋转

---

- LL 型

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012205503654.png" alt="image-20241012205503654" style="zoom:50%;" />

> 确定类型

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012210255182.png" alt="image-20241012210255182" style="zoom:40%;" />

> LL(RR) 变色操作：r 变 s，s 变 p，p 变黑

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012210702979.png" alt="image-20241012210702979" style="zoom:50%;" />

> 完成之后右旋

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241012210825161.png" alt="image-20241012210825161" style="zoom:50%;" />

- RL 型

![image-20241013102226992](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013102226992.png)

![image-20241013102640563](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013102640563.png)

![image-20241013102658049](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013102658049.png)

- **兄弟是黑色**
- **但是兄弟的孩子都是黑色**：兄弟变红，双黑上移

---

> 这里要删除节点 `9`

![image-20241013103119526](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013103119526.png)

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013140503338.png" alt="image-20241013140503338" style="zoom:76%;" />

> 这个时候出现了一个问题，就是黑路同被破坏了
>
> 所以要修复这个时候的节点 `8`，既经过其一定会少一个
>
> 因为这个父亲节点既不是红色，也不是根，所以他的修复方法和

![image-20241013140742657](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013140742657.png)

- 删除节点的兄弟是红色
- 兄弟是红色：兄父变色，朝双黑旋转 

![image-20241013222649144](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013222649144.png)

### 7.4 二分查找

> 我们就记忆闭区间的就行 $[0,size()-1]$

```c++

```

<br>

### 7.5 B 树

---

#### 7.5.1 由来

> 数据太大不得不放在硬盘中，但是从硬盘中读取数据较慢，于是导致了一个问题访问速度和树的高度建立了关系

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241017134436758.png" alt="image-20241017134436758" style="zoom:50%;" />

> 减小高度来加快访问速度

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241017134739371.png" alt="image-20241017134739371" style="zoom:50%;" />

#### 7.5.2 性质

> 对于结果是向上取整的

![image-20241017160301837](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241017160301837.png)

#### 7.5.3 插入操作

> 对于插入操作，我们不可以破坏树的性质，所以我们要检查有没有超过 `m-1` 个元素
>
> - 如果没有溢出，那么久不需要调整
> - 否则中间元素 $[\frac{m}{2}]$ 上移，两边分裂，一直到不溢出为止

![image-20241018173533880](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241018173533880.png)

> 再一次溢出，再一次处理

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241018173607875.png" alt="image-20241018173607875" style="zoom:93%;" />

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241018173721057.png" alt="image-20241018173721057" style="zoom:80%;" />

#### 7.5.4 删除操作

> 对于删除节点只有一个问题要在乎，就是下溢出，既：一个分支至少有 $[\frac{m}{2}] - 1$  个叶子

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241018192033371.png" alt="image-20241018192033371" style="zoom:50%;" />

> 这里看一个溢出的问题

- 看一个可以借的情况

![image-20241020180942174](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020180942174.png)

> 直接借是不可以的，要保证借了之后我们的性质不被破坏
>
> 随意左右都可以的
>
> **记住一个要领，就是父亲的节点下来到删除的位置，然后兄弟节点补到父亲下来的位置**

![image-20241020182141104](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020182141104.png)

- 如果两个兄弟都不构借的时候，我们就来一个合并

![image-20241020181452292](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020181452292.png)

> 删除了当前的节点之后，我们就出现了下溢出的问题，于是向和两边兄弟借，但是他们都不够借
>
> 于是这个节点应该和左/右兄弟合并
>
> **父亲下移到左，然后右合并过来**，一定要这么做不然会破坏性质

![image-20241020181826910](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020181826910.png)

![image-20241020182402513](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020182402513.png)

#### 7.6 B+ 树

---

> [讲解](https://www.bilibili.com/video/BV1bs421u7pY?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a)
>
> 多层索引结构，于是实现利用上层的索引查询下层的，加速查询

![image-20241020183340852](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020183340852.png)

![image-20241020183809051](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241020183809051.png)

<br>

## 8. 排序

---

![image-20241031130954109](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241031130954109.png)

<br>

### 8.1 快速排序

> 顺带一提我们的随机种子的写法

```c++
std::srand(static_cast<unsigned int>(std::time(nullptr))); // 设置随机种子
```

> 主体结构

```c++
template<class T>
int my_partition(vector<T> &arr, int low, int high) {
    int randomIndex = std::rand() % (high - low + 1) + low;
    T Pivot = arr[randomIndex];

    std::swap(arr[randomIndex], arr[low]); // 将Pivot放到低位

    while (low < high) {
        while (low < high && arr[high] >= Pivot) --high;
        arr[low] = arr[high]; // 移动比Pivot小的元素到低位
        while (low < high && arr[low] <= Pivot) ++low;
        arr[high] = arr[low]; // 移动比Pivot大的元素到高位
    }

    arr[low] = Pivot;	 // 将Pivot放回正确位置
    return low; 		 // 返回Pivot的最终位置
}

template <class T>
void quickSort(vector<T> &arr, int low, int high) {
    if (low >= high) return;
    int mid = my_partition(arr, low, high);
    quickSort(arr, low, mid - 1);
    quickSort(arr, mid + 1, high);
}
```

### ==8.2  希尔排序==

```c++
template <class T>
void shellSort(vector<T> &arr) {
    int n = arr.size();
    // 初始增量
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 插入排序
        for (int i = gap; i < n; i++) {
            T temp = arr[i];
            int j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)
                arr[j] = arr[j - gap];
            arr[j] = temp;
        }
    }
}

```

### 8.3 堆排序

---

#### 8.3.1 堆的性质

> 大根堆得到的结果是：递增的
>
> 小根堆相反，是递减的

![image-20241023131408909](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023131408909.png)

> 但是直接看元素的话实际上有点难以理解什么是堆
>
> 可是我们可以使用**二叉树的顺序存储逻辑**来辅助我们

![image-20241023131732594](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023131732594.png)

#### 8.3.2 大根堆

> 如果你默认了他是二叉树的逻辑，你不妨就把一个顺序数组看作为一个层次遍历的结果
>
>  **大根堆** 的定义是：`根 >= 左、右`
>
> **小根堆** 的定义是：`根 <= 子节点`

![image-20241023132005600](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023132005600.png)

> 可以看得出，我们的途中有很多节点其实是不符合性质的，但是问题往往都在分支处
>
> 我们的总体思路：**把所有的非终端节点都检查一遍，是否满足大根堆的要求，如不满足则调整**
>
> 顺带一提
>
> - 分支节点的条件是：$i\leq ⌊\frac{n}{2}⌋ $
> - 叶子节点的条件是：$i>⌊\frac{n}{2}⌋ $

![image-20241023134507687](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023134507687.png)

---

![image-20241023134836300](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023134836300.png)

![image-20241023134906406](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023134906406.png)

![image-20241023135059466](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023135059466.png)

#### 8.3.3 大根堆代码实现

> 第一个节点非空的写法
>
> - 最后一个分支节点的位置 ：`k = [n/2]-1`
> - 任意一个节点的左节点：`2 * i + 1 < n`
> - 任意一个节点的右节点：`2 * i + 2 < n`

```c++
void buildHeap(std::vector<int>& A) {
    // 从最后一个非叶子节点开始调整堆，逐步建立大根堆
    for (int k = A.size() / 2 - 1; k >= 0; --k)
        headAdjust(A, k);
}

template<class T>
void maxHeapAdjust(vector<T> &arr, int k, int heapSize) {
    T k_val = arr[k];
    // 从当前节点的左孩子往下走
    for (int left = 2 * k + 1; left < heapSize; left = 2 * left + 1) {
        // 如果存在右孩子且右孩子比左孩子大
        if (left + 1 < heapSize && arr[left] < arr[left + 1]) ++left;

        // 分支更大结束当前分支
        if (arr[left] <= k_val) break;
        // 孩子比分支节点大，交换并下坠调整
        arr[k] = arr[left];
        // 从节点位置哪里开始调整
        k = left;	// k 更新为下坠的位置
    }
    // 根节点回到原来的位置
    arr[k] = k_val;
}
```

#### 8.3.4 大根堆实现的排序

> 堆排序:每一趟将堆顶元素加入有序子序列 (与待排序序列中的最后一个元素交换)

![image-20241023144017824](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20241023144017824.png)

```c++
template<class T>
void heapSort(vector<T> &arr) {
    this->buildHeap(arr);
    for (int i = arr.size() - 1; i > 0; --i) {
        // 交换最大值到末尾
        swap(arr[0], arr[i]);
        // 调整堆的有效范围为 [0, i] 而不是一直都是 [0, arr.size()-1]
        this->maxHeapAdjust(arr, 0, i);
    }
}
```

### 8.4 归并排序

---

#### 8.4.1 逻辑原理

![893F151A-F160-45B8-BC44-292359D0117D_1_102_o](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/893F151A-F160-45B8-BC44-292359D0117D_1_102_o.jpeg)

#### 8.4.2 代码实现

```c++
// 实现链表类似的结构排序
template<class T>
void merge(vector<T> & arr, const int low, const int high) {
        vector<T> temp;
        for (const auto & e : arr) temp.emplace_back(e);
		
	    //	划分区间为两个部分，然后两个区间从小到大变成一个新的区间
        const int mid = low + (high - low) / 2;

        int k = low;
        int i = low, j = mid + 1;

        while (i <= mid && j <= high) {
            if (temp[low] <= temp[j]) arr[k++] = temp[i++];
            else arr[k++] = temp[j++];
        }
		
        while (i <= mid) { arr[k++] = temp[i++]; }
        while (j <= high) { arr[k++] = temp[j++]; }
}


template<class T>
void mergeSort(vector<T> & arr, int low, int high) {
    int mid = low + (high - low) / 2;
    
    // 这里使用二叉树的后序，开始递归的时候拆分区间，回溯到当前区间的时候拆分合并
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
	
    // 回溯的时候建立起我们的逻辑
    merge(arr, low, mid, high);
}
```

### 8.5 基数排序

> [逻辑](https://www.bilibili.com/video/BV1YM4y1A7wi/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)

### 8.6 外部排序

> 针对数据存储在外部的硬盘，然后数据因为是分块存储，就和在内存用的算法不太一样，所以分成内外部排序

#### 8.6.1 外部的数据形式

> 对于外部的数据，我们分块来读取到内存中，对块数据排好序，然后存到磁盘中

![image-20241031145357602](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241031145357602.png)

> 所以大部分的外部排序，都是解决如何对外部问排序，大部分的思路都是归并，但是如何让归并更快，就建立了很多的算法







## 9. 滑动窗口

> 这类算法就是找到符合某一条件的连续子集
>
> 控制窗口的边界就是控制左右指针
>
> 主体思路是：

![image-20241013104141115](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/uPic/image-20241013104141115.png)

### 9.1 最长子集

> 每次移动右指针，把新元素加入窗口。
>
> 如果窗口不满足条件，通过移动左指针缩小窗口直到满足条件。
>
> 每次找到满足条件的窗口时，更新最优解。

```c++
// 最长模板：
初始化 left, right, result, bestResult
while (右指针没有到结尾) {
    // while 和 加入新的元素这一步有的时候可以换顺序
    // 譬如说要先检查条件才能保证是不是要插入
    // 当然对于那种，你可以在加元素多写一个 if 判断
    // 如果你写了 if 判断 else 不满足要求的时候，你也得保证加入新的元素
    窗口扩大，加入 right 对应元素，更新当前 result
    while (result 不满足要求) {
        窗口缩小，移除 left 对应元素，left 右移
    }
    更新最优结果 bestResult
    right++;
}
返回 bestResult;
```

### 9.2 最短子集

> 每次移动右指针，把新元素加入窗口。
>
> 一旦窗口满足条件，通过移动左指针缩小窗口，直到不再满足条件，同时更新最优解。
>
> 然后再继续移动右指针。

```c++
// 最短模板：
初始化 left, right, result, bestResult
while (右指针没有到结尾) {
    窗口扩大，加入 right 对应元素，更新当前 result
    while (result 满足要求) {
        更新最优结果 bestResult
        窗口缩小，移除 left 对应元素，left 右移
    }
    right++;
}
返回 bestResult;
```

### 9.3 定长窗口

> 这里不需要考虑条件的满足与否，只需要在每次窗口移动时直接更新结果

```c++
// 定长窗口模板：
初始化 left, right, result
while (right 没有到达结尾) {
    窗口扩大，加入 right 对应元素
    if (right - left + 1 == 固定窗口长度) {
        更新当前 result
        left++;  // 窗口左边界同步右移，保持窗口长度固定
    }
    right++;
}
返回 result;
```



## 回溯

----

### N 皇后问题核心思路

<img src="https://pic1.zhimg.com/v2-fb05219416282867dc9fbd8b41b3b0ac.webp" alt="img" style="zoom:80%;" />

#### 如何检测皇后是否出现在了其他皇后的对角

>  例子：4x4 棋盘

> #### 主对角线（`row - col` 相同）
>
> - `(0,0)`、`(1,1)`、`(2,2)`、`(3,3)`：它们的 `row - col` 都等于 `0`，所以这些位置在同一条主对角线上。
>- `(0,1)`、`(1,2)`、`(2,3)`：它们的 `row - col` 都等于 `-1`，也在同一条主对角线上。
> 
> #### 副对角线（`row + col` 相同）
>
> - `(0,3)`、`(1,2)`、`(2,1)`、`(3,0)`：它们的 `row + col` 都等于 `3`，所以这些位置在同一条副对角线上。
>- `(0,2)`、`(1,1)`、`(2,0)`：它们的 `row + col` 都等于 `2`，也在同一条副对角线上。
> 

#### 如何用这些规律在 N 皇后问题中剪枝


>在回溯时，我们用一个数组来标记`哪些对角线已经有皇后占据`。例如：
> 
>- 使用 `diag1[row - col + (N-1)]` 标记主对角线，`row - col + (N-1)` 是为了保证索引是非负数，因为 `row - col` 的值可能为负。
> 
>	- 主对角线的索引公式是 `row - col`，它的值范围从 `-(N-1)` 到 `(N-1)`
> 
>	- | 位置 (row, col) | row - col  | 加上 `N-1 = 3` 后的结果（索引） |
> 		| :-------------- | :--------- | :-----------------------------: |
>		| (0, 3)          | 0 - 3 = -3 |           -3 + 3 = 0            |
> 		| (1, 2)          | 1 - 2 = -1 |           -1 + 3 = 2            |
> 		| (2, 3)          | 2 - 3 = -1 |           -1 + 3 = 2            |
> 		| (0, 1)          | 0 - 1 = -1 |           -1 + 3 = 2            |
> 
> - 使用 `diag2[row + col]` 标记副对角线。
> 


#### 为什么对角线开辟的空间是 $2N-1$


> **主对角线**：`row - col` 的取值范围是 −3 到 3。
>
> ​	通过加 `N−1` 来平移，实际对应的索引范围是 `−3 + (4 − 1) = 0` 到  `3 + (4 - 1) = 6`，所以我们需要 7 个位置来存储主对角线的信息
>
> **副对角线**：`row + col` 的取值范围是 `0` 到 `6`，也是 7 个位置。

<br>

### 完整代码

```c++
class Solution {
private:
    int N; // 棋盘大小
    vector<int> queens;     // 记录每行皇后所在的列, index 为 Row 存储的值是 Col
    vector<bool> columns;   // 记录列的占用情况
    vector<bool> diag1;     // 记录主对角线的占用情况
    vector<bool> diag2;     // 记录副对角线的占用情况
    vector<vector<string>> solutions; // 保存所有的解
public:
    vector<vector<string>> solveNQueens(int n) {
        N = n;
        // 初始化
        queens.resize(N);
        columns.assign(N, false); 
        diag1.assign(2 * N - 1, false); 
        diag2.assign(2 * N - 1, false); 
        dfs(0);  // 从 0 层开始递归
        return solutions;
    }

    void dfs(int row) {
        // 如果深度达到了 n 那么就返回一个解了
        if (row == N) {
            // 初始化空棋盘 N * N
            vector<string> board(N, string(N, '.')); 
            // 根据皇后所在的位置来标记 Q
            for (int row = 0; row < board.size(); row++) 
                board[row][queens[row]] = 'Q';
            solutions.emplace_back(board);
            return; 
        }

        for (int col = 0; col < N; col++) {
            // 避免皇后之间的互相攻击
            if (columns[col] || diag1[row - col + N - 1] || diag2[row + col])  continue;

            // 放入 Q
            queens[row] = col;  // 记录当前行的 Q 所在 col 的位置
            // Q 会 row 和 diag1 和 diag2
            // 所以 column[col] 代表这一列是不可以用的
            // 对于对角线的解释，前面
            columns[col] = diag1[row - col + N - 1] = diag2[row + col] = true;

            // 递归
            dfs(row + 1);

            // 回溯：解除落子点，还有对角元素存储情况
            columns[col] = diag1[row - col + N - 1] = diag2[row + col] = false;
        }
    }
};
```
