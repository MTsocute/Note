# 1. 硬件相关知识

---

- [Type-C 尚硅谷视频介绍](https://www.bilibili.com/video/BV1AT421Y7DS/?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a&p=53)
- [编码器介绍](https://www.bilibili.com/video/BV1im42137c2/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)

<br>

## 1. Type-C 3.0

----

### 1. Type-C  的 Pin 以及对应的功能

> 因为这种对称的关系, 所以无论正反插其实都是可以的

![image-20250420154905743](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420154905743.png)

### 2. 24-PIN 功能表

> 功能表
>
> **当然有些也用不上那么多功能, 所以有些其实 PIN 要少一些**

| 引脚        | 名称        | 功能简介                          | 备注                             |
| ----------- | ----------- | --------------------------------- | -------------------------------- |
| A1 / B1     | GND         | 接地                              | 电源负极                         |
| A4 / B4     | VBUS        | 电源正极                          | 通常 5V，也可能是 20V（PD 模式） |
| A5 / B5     | CC1 / CC2   | 配置通道（Configuration Channel） | 正反识别、角色检测、功率协商     |
| A6 / A7     | D+ / D−     | USB 2.0 数据线                    | 兼容老设备                       |
| B6 / B7     | D+ / D−     | USB 2.0 数据线                    | 正反插备用                       |
| **A2 / A3** | TX1+ / TX1− | USB 3.x TX 通道（发送）           | 超高速数据                       |
| B10/B11     | TX2+ / TX2− | USB 3.x TX 通道（发送）           | 反插时使用                       |
| A10/A11     | RX2+ / RX2− | USB 3.x RX 通道（接收）           | 反插时使用                       |
| B2 / B3     | RX1+ / RX1− | USB 3.x RX 通道（接收）           | 正插时使用                       |
| **A8 / B8** | SBU1 / SBU2 | Sideband Use 侧带信号             | 用于音频、视频（DisplayPort 等） |
| A9 / B9     | VCONN       | 给线缆内部芯片供电                | 通常通过 CC 反向脚供电           |

> 举例一个 16 PIN 的

![image-20250420155532603](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420155532603.png)

### 3. 24-PIN VS 16-PIN

| 项目                     | 16PIN Type-C | 24PIN Type-C        |
| ------------------------ | ------------ | ------------------- |
| 引脚数量                 | 16（简化版） | 24（全功能）        |
| 支持 USB 2.0             | ✅ 是的       | ✅ 是的              |
| 支持 USB 3.x             | ❌ 不支持     | ✅ 是的              |
| 支持 PD 快充             | ✅ 可支持     | ✅ 可支持（更强）    |
| 支持视频输出（Alt Mode） | ❌ 不支持     | ✅ DisplayPort, HDMI |
| 支持 Thunderbolt         | ❌ 不支持     | ✅ 是的              |
| 成本                     | 💰 低         | 💰 高                |

### 4. 16-PIN 绘制

![image-20250420163503678](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420163503678.png)

### 5. 实物图片

> 背面那个两排在焊接难度上有点大的

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420155218064.png" alt="image-20250420155218064" style="zoom:77%;" />

### 6. Type-C 充电协议

> 你可以看到这个**输出其实是有多个结果**的, 这个是由快充芯片决定的
>
> 譬如说 USB 设备会通过改变USB端口的D+和D-电压组合向充电器发送信号，请求更高的充电电压
>
> 所以如果你没有充电芯片的设计的话, 其实最后拿到的供电就是 5V

![image-20250420164350551](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420164350551.png)

## 2. 降压模块

---

### 1. DCDC

- [DCDC 降压](https://www.bilibili.com/video/BV1644y1q74w/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)
- [DCDC 原理图实际绘制教学](https://www.bilibili.com/video/BV1xSzpYjEpd?spm_id_from=333.788.recommend_more_video.0&vd_source=b47817c1aa0db593f452034d53d4273a)

> 大致意思就是我们可以通过类似 PWM 那种方法, 用占空比实现降低电压, 譬如说这里的占空比是 1/2 所以电压就降成了一半
>

![image-20250422120705445](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422120705445.png)

### 2. DCDC 硬件电路实现

> 虽然说降低了电压, 但是只是总额变低了, 他仍然不是一个稳定的值, 而是很多个矩形波
>
> 所以需要下面的电路实现一个整流

<div style="display: flex; justify-content: center;">
  <img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422120944020.png" alt="image-20250422120944020" style="zoom:65%;" />
</div>
- 注意, 这里的电感一开始通电的时候, 其实会抵挡一部分的电压, 然后通过这个, 使得到负载的电压是我们想要的电压
- 电容起到的作用是滤波, 让我们的线条稍微的平滑, 不会特别的尖
- 开关我们最后用的是可控的开关(MOS), 因为电感随着时间长了之后, 其实就不会降低电压了, 所以需要关闭开关再打开
- 关闭开关之后, 电感储能的电释放了, 然后就维持这个 5V 别降太多, 然后再开关闭合, 把降低的拉回去, 就像下面一样, 高低高低的
- 开关的不断开关就像 PWM 一样
- 二极管的作用就是为了防止电感放电的时候出现反向导通

> 效果如下

![image-20250422121531861](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422121531861.png)



<br>

### 3. LDO

> [LDO 原理](https://www.bilibili.com/video/BV1t64y1b7w7/?spm_id_from=333.788.recommend_more_video.-1&vd_source=b47817c1aa0db593f452034d53d4273a)
>
> 实际就是通过分压实现的, 就比方说下面的分压电路

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422123529334.png" alt="image-20250422123529334" style="zoom:57%;" />

但是实际因为我们的电压变化的问题, 所以其实下面的负载电阻没那么稳定,所以我们希望上面的电阻能够智能一些, 根据下面的电阻阻值变化,调节自身的阻值

> 于是就有了下面的电路

### 4. LDO 硬件电路实现

> 具体思路就是通过这个比较器
>
> 看到最右侧的 5V 电压没有, 他会再一次进入到比较器, 和稳压二极管作比较, 通过比较来控制二极管对电压的放大或者变小, 以此来控制电压稳定在 5V

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422123704638.png" alt="image-20250422123704638" style="zoom:70%;" />

> 那么现在左侧的一大堆东西就是我们的智能电阻了, 稳定控制通过其的电压一定是 5V

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422124441767.png" alt="image-20250422124441767" style="zoom:52%;" />

## 3. MAX98357A

---

![image-20250701163806939](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701163806939.png)

​	这个模块多个版本，有一个 `LRC`  然后这个是根据输入的高低电位判断当前数据`左还是右声道`

<br>

### 1. 声道的确定

> 内部框图

![image-20250701164944483](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701164944483.png)

> 注意这个绿色的部分，这个部分就是我们需要比较的电压

![image-20250701164854053](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701164854053.png)

> 如果 SD 引脚悬空的话，默认是$\frac{L+R}{2}$

### 2. 增益的选择

| GAIN\_SLOT 接线方式       | I2S/LJ 增益 (dB) |
| ------------------------- | ---------------- |
| 通过 100kΩ ±5% 电阻接地   | 15               |
| 直接接地                  | 12               |
| 悬空                      | 9                |
| 接 VDD                    | 6                |
| 通过 100kΩ ±5% 电阻接 VDD | 3                |

<br>

## 4. 编码器

---

### 1. 编码器的内部结构

> [!note]
>
> 所以我们的 `DT` 和 `CLK` 其实一直都是高电平，因这个上拉电阻的存在
>
> `SW` 是按下检测，默认接地，所以我们配置 GPIO 的时候，给 SW 上拉就好

![image-20250724113550613](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113550613.png)

### 2. 电平如何突变

![image-20250724113843546](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113843546.png)

> 为此产生的对外波形其实是这样子的

![image-20250724113950073](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113950073.png)

### 3. 两个触电有周期相位的原理

> 就是因为这两个出点和拨片的接触时间永远都不会是同一时刻，所以会存在相位差。
>
> 正转和反转 同 触电 A B 相位前后的关系就显而易见了

![image-20250724114136697](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724114136697.png)

> - A 在前，正转
> - B 在前，反转

![image-20250724114405597](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724114405597.png)

<br>

# 2. 编码

---

<br>

## 1. WAV 编码

---

### 1.1 大小端问题

![image-20250405184910823](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405184910823.png)

> 图例解释
>
> 第一个图是我们的`x86计算机`保存的数据哈, 计算机是小端模式,所以重要的都在前面

![image-20250405184957458](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405184957458.png)

### 1.2 WAV 文件头

> 所有的`WAV` = **44字节 头文件** + **PCM文件** 组成，这个文件头包含语音信号的所有参数信息（声道数、采样率、量化位数、比特率....）
>
> [特别细节的部分可以参考这个文章](https://www.cnblogs.com/LXP-Never/p/15234298.html#blogTitle4)

```c
typedef struct WAV_HEADER_S
{
    char            riffType[4]{'R','I','F','F'};    //4byte,资源交换文件标志:RIFF
    unsigned int    riffSize;                        //4byte,从下个地址到文件结尾的总字节数 = 文件总大小-8
    char            waveType[4]{'W','A','V','E'};    //4byte,wav文件标志:WAVE
    char            formatType[4]{'f','m','t',' '};  //4byte,波形文件标志:fmt(最后一位空格符)
    unsigned int    formatSize{16};                  //4byte,fmt chunk块的大小，不包含自己
    unsigned short  compressionCode{1};              //2byte,格式种类(1-线性pcm-WAVE_FORMAT_PCM,WAVEFORMAT_ADPCM)
    unsigned short  numChannels;                     //2byte,通道数
    unsigned int    sampleRate;                      //4byte,采样率
    unsigned int    bytesPerSecond;                  //4byte,每秒传输速率 = SampleRate * NumChannels * BitsPerSample/8
    unsigned short  blockAlign;                      //2byte,数据块的对齐，即DATA数据块长度 = NumChannels * BitsPerSample/8
    unsigned short  bitsPerSample;                   //2byte,采样精度-PCM位宽
    char            dataType[4]{'d','a','t','a'};    //4byte,数据标志:data
    unsigned int    dataSize;                        //4byte,从下个地址到文件结尾的总字节数。即除了wav header 以外的 pcm data length = 文件大小 - 44
} WAV_HEADER;
```

![](https://upload.wikimedia.org/wikipedia/commons/8/8c/Wave_format.png)

### 1.3 PCM 数据的排列

> 第三个排序是最好的,正好和计算机和ESP一样都是小端序

![image-20250405185913414](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405185913414.png)

### 1.4 制作音频需要的计算

```cpp
FsFile file;  // 定义一个文件对象，用于录音文件操作

const int record_time = 60;  // 定义录音时长（单位：秒）
const char filename[] = "/我的录音.wav";  // 定义录音文件名

// 计算音频数据大小（假设采样率为44100Hz，16位位宽，单声道）
const int waveDataSize = record_time * 88200;  // 88200 = 44100 * (16 / 8 == 2 Byte) * 1（单声道）

// 打开或创建文件
file = sd.open(filename, O_WRITE | O_CREAT);
if (!file) {	
    Serial.println("crate file error");  // 如果文件打开失败，输出错误信息
    return;  // 返回，结束操作
}

// 创建WAV文件头（假设有一个函数CreateWaveHeader用于生成WAV头）
auto header = CreateWaveHeader(1, 44100, 16);  // 参数：通道数、采样率、位宽

// 更新 WAV文件头 中的文件大小字段
header.riffSize = waveDataSize + 44 - 8;  // riffSize = 数据大小 + 44（文件头大小） - 8（RIFF和WAVE部分）
header.dataSize = waveDataSize;  // 更新数据块的大小

// 将WAV文件头写入文件
file.write(&header, 44);  // 写入44字节的文件头
```

<br>

## 2. 电机编码

---

### 1. 编码器的模式

> [!note]
>
> 在 `HAL` 库里面的硬件逻辑：

![image-20250724115512881](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724115512881.png)

- 模式1：在A相的边沿计数(Counting On Tl1 Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122155256.png" alt="image-20250724122155256" style="zoom:50%;" />

- 模式2：在B相的边沿计数(Counting On Tl2 Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122249244.png" alt="image-20250724122249244" style="zoom:50%;" />

- 模式3：双边沿计数(Counting On Both Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122303818.png" alt="image-20250724122303818" style="zoom:50%;" />

> [!important]
>
> 记住，不论是那种模式，采样的时候，我们都是下面的原则计数：

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724124737086.png" alt="image-20250724124737086" style="zoom:67%;" />

### 2. HAL 操作

> [!note]
>
> 接线情况，好像 RX 和 TX 接线有点问题，要注意下

![image-20250724122531946](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122531946.png)

> `CUBEMX UI` 配置

![image-20250724122839351](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122839351.png)

> 编码器部分，我们这样子设置，采用模式 1，然后启用`上升沿捕获`
>
> 如果采用了`下降沿捕获`的话，顺时针是减哦，因为这个时候，因为 A 下降沿的时候，B 是在前面的，采样的时候，就认为是 B 在前，`CNT --`

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724124259685.png" alt="image-20250724124259685" style="zoom:50%;" />

<br>

# 3. 通信

---

- [红外通信介绍](https://www.bilibili.com/video/BV1z8411g7jn/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)
- [MQTT 协议详细介绍](https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html)
- [使用 docker 创建一个 MQTT 服务器](https://mp.weixin.qq.com/s/qYH78Am12sZI5cm2aDYn6Q)
- [蓝牙协议 - 尚硅谷](https://www.bilibili.com/video/BV1RVR3YNEkN?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a&p=5)

## 1.常见的通信和性质

![image-20250114113118335](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114113118335.png)

### 时钟

- **异步通信（Asynchronous）**：通信双方不依赖共享时钟信号，而是通过约定的**波特率（baud rate）**进行数据传输。数据的开始和结束由特定的起始和停止位标识

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122104776.png" alt="s" style="zoom:74%;" />

- **同步通信（Synchronous）**：发送和接收端共享一个时钟信号，通过时钟同步实现数据传输

![image-20250114122036666](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122036666.png)

### 双工

- **全双工**：两个线之间同时可以互相发送数据

![image-20250114113928109](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114113928109.png)

- **半双工**：发送和接受是同一个线，所以不可以同时满足两个功能，就是这种数据一发一回应的模式，所以才有这种 **主从模式**

![image-20250114114043417](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114114043417.png)



### 电平

- **单端通信**：数据通过一个信号线和一个公共地线传输。常见的 RS-232 串口通信属于单端通信。
- **差分通信**：数据通过两根电平互补的信号线传输，例如 RS-485 接口，抗干扰能力更强。

<br>

### 设备

- **点对点通信**：两个设备直接进行通信，双方之间不存在其他中介设备。USART 通信通常是点对点的，如电脑和 STM32 之间的串口通信
- **多设备通信**：指在一个通信网络中，多个设备相互传递数据的通信模式。多设备通信通常包括多方参与，可以是点对多点、广播或点到点的组合

<br>

## 2. USRT 通信

---

### 1. USRT 的性质

> 交叉这一点非常的重要，我们 STM 32 的串口和 COM3 的端口要注意交叉

![image-20250104183706554](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104183706554.png)

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104123126284.png" alt="image-20250104123126284" style="zoom:70%;" />

### 2. 电平标准

> 电平标准是数据`1`和数据`0`的表达方式

- TTL电平：`+3.3V`或`+5V`表示 1，`0V` 表示 0

- RS232电平：`-3~-15V`表示 1，`+3~+15V`表示 0

- RS485电平：两线压差`+2~+6V`表示 1，`-6~-2V`表示 0（差分信号）

### $\textcolor{pink}{3. 串口参数和时序}$

![image-20250104124042931](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104124042931.png)

> 波特率：每隔多少时间发送一个电平
>
> - 波特率换时间就是：$\frac{1}{波特率} \times 10^6 \mu s$
> - $波特率 = \frac{f_{PCLK2/1}}{16 \times DIV}$
>
> 起始位：一开始是啥电平，一般是低电平，因为我们一开始是一直是高电平，然后我们转低电平告诉我们数据开始传输了
>
> 数据位：譬如说我要发送，`0x0F -> 0000 1111`，因为**低位先行**所以发送的数据其实是：`1111 0000`，虽然说发送的是反过来的，但是接受的 RX 是接受然后右移，所以最后接受的数据会再翻转一次，结果仍然是正的
>
> 校验码：[参考这个视频](https://www.bilibili.com/video/BV1HbSBYGEAQ/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)，因为我们采用的实际上是 奇偶效验，更好的方法可以参考 CRC 校验

<br>

## 3. I2C 通信

---

### 1. I2C 的性质

> - I2C（Inter IC Bus）是由`Philips` 公司开发的一种通用数据总线
> - 两根通信线：SCL（Serial Clock）、SDA（Serial Data）
> - 带数据应答
> - 支持总线挂载多设备（**一主多从**、多主多从），我们主要学习第一种模式

![image-20250114120856778](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114120856778.png)

<br>

### 2. 一主多从模式

> ### 防止短路的规定
>
> - 设备的SCL和SDA均要配置成**开漏输出模式**
>
> - SCL和SDA各添加一个**上拉电阻**，阻值一般为4.7KΩ左右
>
> - 所以如果是软件模拟，默认是上拉，设置成开漏（不让他具有自己下拉的能力，让外部提供高电平）

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114121136522.png" alt="image-20250114121136522" style="zoom:67%;" />

![image-20250713215545517](C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20250713215545517.png)

### 3. 基本时序

---

#### 3.1 开始和停止条件

- **起始条件**：SCL**高电平**期间，SDA从高电平切换到低电平

![image-20250114122440066](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122440066.png)

- **终止条件**：SCL**高电平**期间，SDA从低电平切换到高电平

![image-20250114122551051](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122551051.png)

#### 3.2 发送一个字节

> **从机**SCL**低电平**期间，**主机**将数据位依次放到SDA线上（高位先行），然后释放SCL，**从机将在SCL高电平期间读取数据位**，*所以SCL高电平期间SDA不允许有数据变化*，依次循环上述过程8次，即可发送一个字节
>
> SCL 是一个垂直运输机，SDA 就是这个运输机上的东西，一开始就是被放下来准备接东西（低电平），上升去之后（就变成高电平了），就把东西给给运走了。然后还没有放下来运下一次的东西之前，我们不允许放下一次的东西。
>
> 我们的东西排布一开始是 0 1 2 3 4 5 6 7 8，但是接受的肯定是先拿到 0，所以他们哪里的排序就是 8 7 6 5 4 3 2 1 0，也就是所谓的**高位先行**

![image-20250114123754375](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114123754375.png)

- SDA 在 SCL 低电平发生了变化，于是 SCL 拉高，然后读取 SDA 电平



#### 3.3 接受一个字节

> 这里主从的关系换一下，发送是从，接受是主
>
> **主机**SCL低电平期间，**从机**将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL**高电平期间读取**数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）

![image-20250114125425769](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114125425769.png)

#### 3.4 ACK

> - **发送应答**：**主机**在**接收完**一个字节之后，在下一个时钟等待**从机发送一位数据**，数据 0 表示应答，数据 1 表示非应答
> - **接收应答**：主机在**发送完**一个字节之后，在下一个时钟等待**主机接收一位数据**，判断从机是否应答，数据 0 表示应答，数据1 表示非应答*（主机在接收之前，需要释放SDA）*

![image-20250114131351181](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114131351181.png)

**应答的典型情况示意**

| 操作           | 数据方向    | 谁发送 ACK/NACK   | 说明                                     |
| -------------- | ----------- | ----------------- | ---------------------------------------- |
| 地址帧         | 主机 → 从机 | 从机发送 ACK      | 地址匹配则从机响应，否则 NACK            |
| 数据帧（写入） | 主机 → 从机 | 从机发送 ACK      | 从机接收数据成功，否则 NACK              |
| 数据帧（读取） | 从机 → 主机 | 主机发送 ACK/NACK | 主机需要更多数据发送 ACK，结束时发送 NAC |

<br>

### 4. 一帧完整的数据

---

#### 1. 写数据帧

>  **R/W 标志位**：写操作为 `0`
>
>  **应答位 1 （ACK）**：
>
>  - 从机接收到地址帧后，如果识别出自己的地址，会拉低 SDA，表示 ACK（应答）
>  - 如果没有从机响应，则 SDA 保持高电平，表示 NACK
>
>  **应答位 2（ACK/NACK）**：
>
>  - 从机接收数据后，若接收成功，会返回 ACK。
>  - 如果接收失败或从机不准备继续通信，会返回 NACK。

![image-2025011413160+5578](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114131605578.png)

- 简化表示

```scss
// ... 表示重复的 | Data (8 bits) | ACK |
| Start | Address (7/10 bits) + Write(0) | ACK | Data (8 bits) | ACK | ... | Stop |
```

![image-20250713233800925](C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20250713233800925.png)

<br>

#### 2. 读数据帧

> **应答位 1（ACK）**：
>
> - 从机识别出地址后，会拉低 SDA，表示 ACK。
>
> **应答位 2（ACK/NACK）**：
>
> - 主机接收到数据后，若需要继续接收数据，会发送 ACK。
> - 若不需要继续接收数据，则发送 NACK。

```scss
| Start | Address (7/10 bits) + Read(1) | ACK | Data (8 bits) | ACK/NACK | ... | Stop |
```

- 设备地址是厂商给我们的，所以可以查手册找到，然后我们的地址一般都是 7 位，所以一共有 $2^7 -1$ 那么多个
- 当然如果不同硬件的设备地址重复了，也可以自己修改，可以通过电路硬件改变低位，实现改变数据

#### 3. 复合数据帧

> 这里你会发现一个有意思的问题，就是我们的读取数据和写数据不一样，写数据还得指定寄存器的地址，然后才可以开始，但是读数据没有指针，那他咋找到的呢？
>
> 实际上就是根据上一次写入数据到哪里，他才读取哪里，所以为了确保我们一定读取在对的寄存器的位置，我们就有了下面的格式，复合格式
>
> 即写数据帧但是删除掉要写入的数据部分 + 完整的读数据帧

![image-20250114143504008](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114143504008.png)

```scss
// Slave
| Start | Address (7/10 bits) + Write(0) | ACK | Reg Address (8 bits) | ACK |
+
// Master
| Repeated Start | Address (7/10 bits) + Read(1) | ACK | Data (8 bits) | ACK/NACK | Stop |
```

<br>

## 4. SPI 通信

> - SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线
> - 四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）
> - 同步，全双工
> - 支持总线挂载多设备（一主多从）

### 1. 硬件电路

> 因为是全双工，所以和 SDA 不太一样，有两个线来接受输入和输出，而且选择从机也不再想 I2C 一样发送地址到从机看有无应答，而是直接使用 SS 线去找从机，相当于一个从机设备一根单独的线，给对应的 SS 高电平就是去找对应的从机
>
> **输出引脚**配置为**推挽输出（PP）**，输入引脚配置为浮空或**上拉输入**，所以电路高电平驱动很强，上升速度快
>
> **MOSI (主设备输出数据)** 连接到 **DI (设备数据输入)**。
>
> **MISO (主设备接收数据)** 连接到 **DO (设备数据输出)**。

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250119103908324.png" alt="image-20250119103908324" style="zoom:67%;" />

### 2. SPI 移位示意图

> SPI（串行外设接口）通信中的数据传输过程是基于移位寄存器的，它通过时钟信号（SCK）同步传输数据
>
> 高电平的时候输出数据，低电平的时候读取数据，两个数据的轮流的读取写入，实现了数据的交换，所以 SPI 的数据就是这么一个数据交换的过程，**也就实现了发送的时候同时接受**
>
> 如果我们只想发送，那就不管接受的数据就好，如果我们只想接受，那就发送 `0x00` 等没用数据就行，所以有点浪费，因为i我们在做单独的 I/O 的时候，其实不需要两个线的资源都使用，没必要交换数据

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250119104938946.png" alt="image-20250119104938946" style="zoom:67%;" />

> 效果演示

<img src="https://i-blog.csdnimg.cn/blog_migrate/08aeef78767d385476a91f849b155617.gif" alt="img" style="zoom:67%;" />

### 3. SPI 时序

---

#### 1. 起始和终止条件

> 相对于 $I^2C$ 确实简单许多，不需要 SDA 和 SCL 同时配合了



## 5. NEC 红外通信协议

---

### 1. NEC 协议的特点

> ### （1）8位地址和8位命令长度：
>
> - NEC协议使用**8位地址码和8位命令码**。
>
> ### （2）扩展模式可用，加倍地址大小：
>
> - NEC协议有一个扩展模式，可以将地址长度从8位扩展到16位，从而提供更多的地址空间，允许更多的设备被唯一标识。
>
> ### （3）地址和命令都传输两次以提高可靠性：
>
> - 为了确保数据的可靠性，NEC协议会将地址和命令各发送两次。第一次发送原始值，第二次发送其反码（inverted code）。
>
> ### （5）载波频率为38kHz：
>
> - 红外信号的载波频率为38kHz，这是红外通信中常用的频率，可以确保信号的传输效率和抗干扰能力。
> - 这个载波可以通过 PWM 那种间歇性闪烁的效果, 虽然不会改变强度, 但是这个就区分了自然光红外和我们的红外  
> - ![image-20250323121130267](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323121130267.png)
> - ![image-20250323121155124](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323121155124.png)
>
> ### （6）位时间是1.125ms或2.25ms：
>
> - 在NEC协议中，每个位的持续时间可以是1.125ms或2.25ms，这取决于位的值。逻辑"0"通常用一个较短的脉冲表示，而逻辑"1"用一个较长的脉冲表示。这种编码方式有助于接收器区分逻辑"0"和逻辑"1"
> - **仔细看高电平的部分,不是平的,而是38kHz载波的夹杂效果**
>
> ![img](https://i-blog.csdnimg.cn/direct/26ba4ece8bfe48e5875ca3b8f5935a2e.png)
>
> ### **（7） 完整的数据传输格式：** 
>
> -  **引导码+8位地址码+8位地址反码+8位命令码+8位命令反码。** 

### 2. NEC 协议

> 如图展示了NEC协议的一个典型脉冲序列。
>
> 根据这个协议，**最低位（LSB）首先被传输**。在这个例子中，地址 0x59 和 命令 0x16 被传输。

![image-20250323180005702](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323180005702.png)

消息的开始是一个9ms的AGC脉冲，这个脉冲被用来设置早期红外接收器的增益。这个AGC脉冲之后是一个4.5ms的间隙，紧接着是地址和命令的传输。

地址和命令各传输两次，第二次所有位都取反，可以用于验证接收到的消息。由于每个位都以其取反的长度重复，因此总的传输时间是固定的。如果你不关心这种可靠性，可以忽略取反的值，或者你可以将地址和命令各扩展到16位！ **请注意，在消息的末尾必须跟随一个额外的560µs脉冲，以便能够确定最后一个位的值**

```c
// 发送NEC数据位 0/1
void IR_SendBit(uint8_t bit) {
    if (bit) {                       //数据位1
        TIM_SetCompare3(TIM3, 9);    // 产生560us的高电平
        Delay_us(560);
        TIM_SetCompare3(TIM3, 0);    // 产生1680us的低电平
        Delay_us(1680);
    } else {                         //数据位0
        TIM_SetCompare3(TIM3, 9);    // 产生560us的高电平
        Delay_us(560);
        TIM_SetCompare3(TIM3, 0);    // 产生560us的低电平
        Delay_us(560);
    }
}
```

<br>

## 6.  I2S

---

> I2S (`Inter-IC Sound`) 专门为音频而开发的一个通讯协议,
>

![img](https://pic3.zhimg.com/v2-d5d820543ba725cf355548fe5a405852_1440w.jpg)

### 1. 信号线

> - `时钟线（Continues Serial Clock，SCK）`：SCK线提供了同步音频数据传输的时钟信号。确定了数据传输的速度和时序。该时钟也称为[Bit Clock](https://zhida.zhihu.com/search?content_id=239006157&content_type=Article&match_order=1&q=Bit+Clock&zhida_source=entity)（BCLK）。`SCK的频率=2x采样频率x位宽`
> - `左/右声道线（Left-Right Clock，LRCK, WS）`：LRCK线指示了当前传输的是左声道的音频数据还是右声道的音频数据。它被称为[帧同步信号](https://zhida.zhihu.com/search?content_id=239006157&content_type=Article&match_order=1&q=帧同步信号&zhida_source=entity)。`LRCK的频率=采样频率 `
> - `数据线（Serial Data，SD）`：SD线用于传输实际的音频数据。数据的位宽可以根据具体应用而变化，通常为16位或32位。TX方向为：Serial Data Out（SDOUT）；RX方向为：Serial Data In（SDIN）。

> [!important]
>
> 注意看自己的开发板 `I2S` 有啥能力

![image-20250702104628187](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250702104628187.png)

<br>

### 2. 数据传输模式

> **Philips 格式**：数据信号与 WS 信号相比有一个位的位移。WS 信号的占空比为 50%。

![img](https://picx.zhimg.com/v2-fae309fbced394f8ae6fe3ec82c95a4d_1440w.jpg)

> 1. **LRCK（左右声道选择信号）**：LRCK信号用于指示当前数据帧是左声道数据还是右声道数据。当LRCK为低时，表示当前传输的数据是左声道数据；当LRCK为高时，表示当前传输的数据为右声道数据, **LRCK 在一次完整的数据传输周期的中间会翻转（0→1 或 1→0）** --> WS
>
> 2. **SCK（位时钟）**：数据传输的时钟信号。$\textcolor{pink}{在SCK下降沿发送数据，在SCK上升沿采样数据}$
>
> 3. **Data Delay (数据延迟)**：`LRCK` 变化后，数据传输会**延迟 1 个 SCK 周期**
>
> 4. **MSB (Most Significant Bit)**:  高位数据先发, 且与`LRCK` 差 1 个`SCK`

> **PCM 帧同步**：数据有一个位的位移，同时 WS 信号变成脉冲，持续一个 BCLK 周期。

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/wavedrom.svg" alt="wavedrom" style="zoom:125%;" />

<br>

### 3. 数据位宽与位深

---

#### 1. 位宽

> **位宽**: **数据位宽**通常指的是 **I2S 传输的数据总长度**，也就是 **每个声道传输的比特数**

- 数据位宽决定了 I2S 传输时**每个声道所占的时钟周期数**。

```yaml
# 示例（32-bit 位宽，16-bit 数据），因为采样是左右声道，哪怕有一个没有，位宽也是那么多
PCM 数据： 1011 0011 1101 0101 | 0000 0000 0000 0000
                        ↑                 ↑
                   16-bit 数据         16-bit 填充位
```

<br>

#### 2. 位深

> **位深**: **位深**指的是**音频数据本身的精度**，也就是**每个采样点用多少位来表示音频信号**
>
> 位深与信噪比（SNR）相关：

$$
SNR(dB) = 6.02 \times Bit\text{ }Depth + 1.76
$$

- 位深越高，音频的**动态范围**越大，即最小和最大音量的差距，能表示的声音细节就越多

```markdown
> 16-bit：动态范围 ≈ 96 dB（6.02×16+1.76=96.08）
> 24-bit：动态范围 ≈ 144 dB
> 32-bit：动态范围 ≈ 192 dB（但一般人耳听不出这么细的差别）
```

<br>

#### 3. 总结

> 位深是夹在位宽中发送的数据

| 概念         | 作用                 | 计算方式                              | 影响                    |
| ------------ | -------------------- | ------------------------------------- | ----------------------- |
| **数据位宽** | I2S 数据传输最大长度 | 由 I2S 硬件决定                       | 影响数据的 SCK 传输效率 |
| **位深**     | 音频数据的有效位数   | $2^{\text{Bit Depth}}$ 表示的振幅级数 | 影响音频质量            |

<br>

## 7. MQTT 协议

---



<img src="https://www.twilio.com/content/dam/twilio-com/global/en/blog/legacy/2023/what-is-mqtt/MQTT_Diagram_gOmDdU4.png" style="zoom:28%;" />

![02packetformat.png](https://assets.emqx.com/images/e67b987e03842cb19ca7608b14977f36.png?x-image-process=image/resize,w_1520/format,webp)

<br>

## 8. BlueTooth 协议

---

> 新时代的蓝牙都不是为了速度而来的, 而是低功耗, 所以都是 `BLE` 为主流

![image-20250420181150781](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420181150781.png)

<br>

# Ex. 计组

---

## 1. 寻址大小的计算

> 给定你一个模块的寻址地址大小是 $24 \text{ }bit$，所以你就可以知道我们的寻址能力就是 $\frac{2^{24}}{2^{20}} = 16 \text{} MB$

假设你的单片机是 **16 位的**，它只能支持 **16 位地址总线**。这意味着它最多能寻址 2^16 = 65,536 个位置，也就是 **64KB 的存储空间**。

如果你连接的是一个 32MB 的闪存芯片（如 W25Q256），它的寻址范围从 0x000000 到 0x1FFFFFFF。由于你的单片机只有 16 位的寻址能力，**它将无法直接访问超过 64KB 的存储空间**，因此它无法访问到 W25Q256 的大部分存储空间。

<br>

## 2. 计算机组成

![image-20250421175622630](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250421175622630.png)

