# DP

---

> [!note]
>
> **动态规划（Dynamic Programming, DP）**的核心目的：
>
> 通过`保存子问题的结果`，避免递归中的重复计算，把指数级的时间复杂度降到线性或接近线性的程度。

## 🧩 为什么递归会慢

递归通常有这类问题：

- 重复计算相同子问题。
   举例：
   斐波那契递归版

  ```c
  int fib(int n) {
      if (n <= 1) return n;
      return fib(n-1) + fib(n-2);
  }
  ```

  调用树中，`fib(3)` 会被重复计算多次。

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251025104041852.png" alt="image-20251025104041852" style="zoom:70%;" />

- 时间复杂度：
   指数级 → $O(2^n)$。

------

## 💡 动态规划怎么做的

> 动态规划做的两件事：

1. **记忆化（自顶向下）**
    —— 把递归的结果缓存起来，下次遇到相同的输入直接取。

   ```c
   int fib(int n, vector<int>& dp) {
       if (n <= 1) return n;
       if (dp[n] != -1) return dp[n];
       return dp[n] = fib(n-1, dp) + fib(n-2, dp);
   }
   ```

2. **表格法（自底向上）**
    —— 不用递归了，从最小子问题开始顺序求解。

   ```c
   int fib(int n) {
       vector<int> dp(n+1);
       dp[0] = 0; dp[1] = 1;
       for (int i = 2; i <= n; ++i)
           dp[i] = dp[i-1] + dp[i-2];
       return dp[n];
   }
   ```

结果：时间复杂度降到 **O(n)**，空间复杂度可优化到 **O(1)**。



## LeetCode 真题

---

### 53 - 最大子序和

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组**是数组中的一个连续部分。

```bash
示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23
```

#### 暴力求解

> 最粗暴的思路就是直接枚举出所有的子空间拿去值做对比

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int maxSum = INT_MIN;
        for (int i = 0; i < n; ++i) {
            int sum = 0;
            for (int j = i; j < n; ++j) {
                sum += nums[j];
                maxSum = max(maxSum, sum);
            }
        }
        return maxSum;
    }
};
```

> 仔细看这个过程其实如图，从左到右，分别代表着 `i 从 0 到 3`

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251025110855546.png" alt="image-20251025110855546" style="zoom:70%;" />

#### 递归

> 如果我们是从最底部开始的话，你就会发现其实这个和一个树一样，最底下那层就是根节点，然后左右划分区间

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        return helper(nums, 0, nums.size() - 1);
    }

    int helper(vector<int>& nums, int left, int right) {
        if (left == right)
            return nums[left];

        int mid = left + (right - left) / 2;
        int leftMax = helper(nums, left, mid);
        int rightMax = helper(nums, mid + 1, right);

        // 计算跨越中点的最大和
        int leftSum = INT_MIN, sum = 0;
        for (int i = mid; i >= left; --i) {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }
        int rightSum = INT_MIN;
        sum = 0;
        for (int i = mid + 1; i <= right; ++i) {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }

        int crossMax = leftSum + rightSum;
        return max({leftMax, rightMax, crossMax});
    }
};
```

