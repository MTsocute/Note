# Docker

---

- Docker 中文文档

## 运行第一个容器

> 创建一个 mysql docker 

- [对于参数的解释](https://www.bilibili.com/video/BV1HP4118797?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a&p=4)

```shell
docker run -d \
  --name mysql1 \
  -p 3306:3306 \
  -e TZ=Asia/Shanghai \
  -e MYSQL_ROOT_PASSWORD=123 \
  mysql
```

| 参数                         | 全称        | 作用                     | 示例说明                                                     |
| ---------------------------- | ----------- | ------------------------ | ------------------------------------------------------------ |
| `docker run`                 | -           | **启动容器**的核心命令   | 告诉 Docker：我要运行一个容器                                |
| `-d`                         | `--detach`  | **后台运行**容器         | 容器启动后不会占用你当前终端，适合服务类容器如 MySQL         |
| `--name mysql1`              | -           | 给容器起个**名字**       | 以后你可以用 `docker stop mysql1` 或 `docker logs mysql1` 来操作它，而不用记容器 ID |
| `-p 3306:3306`               | `--publish` | **端口映射**             | 把**宿主机的 3306 端口**映射到**容器内的 3306 端口**，这样你就能用 `localhost:3306` 连接 MySQL |
| `-e TZ=Asia/Shanghai`        | `--env`     | 设置**环境变量**         | 设置容器的**时区**为上海，避免时间和系统不一致               |
| `-e MYSQL_ROOT_PASSWORD=123` | `--env`     | 设置 root 用户的**密码** | MySQL 镜像要求必须设置这个变量，否则容器启动失败             |
| `mysql`                      | -           | 使用的**镜像名**         | Docker 会从 [Docker Hub](https://hub.docker.com/_/mysql) 拉取最新版的 MySQL 镜像 |

> [!note]
>
> `-e` 这个参数需要填写什么这个具体去，`Docker Hub` 里面看我们的 `mysql` 的要求

<br>

## Docker 常用的基本命令

| 场景           | 命令                             | 说明                     | 示例                             |
| -------------- | -------------------------------- | ------------------------ | -------------------------------- |
| **镜像操作**   | `docker images`                  | 查看本地镜像             | `docker images`                  |
|                | `docker pull <镜像名>`           | 拉取镜像                 | `docker pull mysql:8.0`          |
|                | `docker rmi <镜像ID>`            | 删除镜像                 | `docker rmi mysql:8.0`           |
|                | `docker build -t <名> .`         | 构建镜像                 | `docker build -t myapp .`        |
| **容器操作**   | `docker ps`                      | 查看运行中的容器         | `docker ps`                      |
|                | `docker ps -a`                   | 查看所有容器（含已停止） | `docker ps -a`                   |
|                | `docker run [参数] <镜像>`       | 新建并启动容器           | `docker run -d --name web nginx` |
|                | `docker start <容器名>`          | 启动已存在的容器         | `docker start mysql1`            |
|                | `docker stop <容器名>`           | 停止容器                 | `docker stop mysql1`             |
|                | `docker restart <容器名>`        | 重启容器                 | `docker restart mysql1`          |
|                | `docker rm <容器名>`             | 删除容器                 | `docker rm mysql1`               |
|                | `docker rename <旧名> <新名>`    | 重命名容器               | `docker rename mysql1 db1`       |
| **日志与调试** | `docker logs <容器名>`           | 查看容器日志             | `docker logs mysql1`             |
|                | `docker exec -it <容器名> bash`  | 进入容器终端             | `docker exec -it mysql1 bash`    |
|                | `docker top <容器名>`            | 查看容器进程             | `docker top mysql1`              |
| **数据卷**     | `docker volume ls`               | 查看数据卷               | `docker volume ls`               |
|                | `docker volume create <卷名>`    | 创建数据卷               | `docker volume create mydata`    |
|                | `docker volume rm <卷名>`        | 删除数据卷               | `docker volume rm mydata`        |
| **网络**       | `docker network ls`              | 查看网络                 | `docker network ls`              |
|                | `docker network create <网络名>` | 创建网络                 | `docker network create mynet`    |
| **清理**       | `docker system prune`            | 清理无用资源（慎用）     | `docker system prune -f`         |
|                | `docker container prune`         | 清理已停止的容器         | `docker container prune -f`      |
|                | `docker image prune`             | 清理无用镜像             | `docker image prune -f`          |

> 常用组合操作

| 目的                     | 命令                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 一键删除所有已停止的容器 | `docker rm $(docker ps -aq)`                                 |
| 一键删除所有未使用的镜像 | `docker rmi $(docker images -q)`                             |
| 查看容器实时日志         | `docker logs -f <容器名>`                                    |
| 复制文件到容器内         | `docker cp 本地路径 容器名:容器路径`                         |
| 查看容器内文件结构       | `docker exec <容器名> ls /`                                  |
| 查看开启容器的信息       | `docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}\t{{.Status}}` |
| 查看所有容器（含已停止） | `docker ps -a`                                               |

<br>

## Dockerfile

---

> [!note]
>
> `Dockerfile`就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建`镜像`。
>
> 常见指令如下：

![image-20250802201605156](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250802201605156.png)

> 让我们跟着官方，[构建自己的第一个 docker image](https://docs.docker.com/guides/golang/build-images/)
>
> ```bash
> git clone https://github.com/docker/docker-gs-ping
> ```
>
> 这里是一个 go 的案例

```dockerfile
# ? go 的版本
FROM golang:1.25

# ? 后续所有命令（如 COPY、RUN）都在 /usr/src/app 目录下执行
WORKDIR /usr/src/app

# Download Go modules
COPY go.mod go.sum ./
RUN go mod download

COPY *.go ./

# Build
# ? 1. app 是编译后生成的二进制文件名
# ? 2. 是 Go 的通配符语法，意思是“当前目录及其所有子目录下的所有 Go 包
RUN go build -v -o /usr/local/bin/app ./...

EXPOSE 8080

# Run
# * 执行刚才编译好的二进制文件
CMD ["app"]
```

### 构建可能会遇到的问题

> [!warning]
>
> ERROR: failed to build: failed to solve: failed to fetch oauth token: Post "https://auth.docker.io/token": dial tcp [2a03:2880:f111:83:face:b00c:0:25de]:443: i/o timeout
> Failed to deploy 'docker-gs-ping Dockerfile: docker-gs-ping/Dockerfile': Image build failed with exit code 1.

​	**buildx 拉镜像时是`客户端`直接去 Docker Hub 拿 token**，所以即使你 `docker login` 了，buildx 也可能绕过 daemon 自己去请求——这就触发了 401 或网络问题，也就是没请过 proxy 直接请求

​	你需要直接在buildx调用时配置代理，例如 `HTTPS_PROXY=... docker buildx build` 用于此类请求。可选地，你可以通过设置 `BUILDKIT_NO_CLIENT_TOKEN=1` 来禁用客户端认证，这将强制 buildx 将你的凭据发送给buildkit守护进程，而不是让buildx自己进行认证

> [!important]
>
> 你可以赋值对应终端的环境变量类型，然后粘贴到自己的终端中，来启动终端的代理

<img src="C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20250925084503583.png" alt="image-20250925084503583" style="zoom:76%;" />

```bash
# 这个设置的是临时变量，所以并不是长期有效
C:\Users\shuhe\Desktop> $env:HTTP_PROXY="http://127.0.0.1:7897"; $env:HTTPS_PROXY="http://127.0.0.1:7897"
```

> 我们不妨写一个脚本，临时生效

```powershell
# -*- coding: utf-8 -*-
$env:HTTP_PROXY = "http://127.0.0.1:7897"
$env:HTTPS_PROXY = "http://127.0.0.1:7897"
Write-Host "代理已设置，仅对当前 PowerShell 会话有效。"
```

<br>

### 修改自己构建的容器的标签

```bash
# new tag
docker image tag docker-gs-ping:latest docker-gs-ping:v1.0


### 
docker image ls

REPOSITORY                       TAG       IMAGE ID       CREATED         SIZE
docker-gs-ping                   latest    7f153fbcc0a8   6 minutes ago   1.11GB
docker-gs-ping                   v1.0      7f153fbcc0a8   6 minutes ago   1.11GB
...


# del old image
docker image rm docker-gs-ping:v1.0
```



### 使用自己的镜像创建容器

```bash
docker run -d --name ping-container -p 8080:8080 docker-gs-ping:v1.0
```

> 然后我们就去测试一下吧

```http
GET http://127.0.0.1:8080/
```

## Multi-stage builds && Scratch

> 你可能发现了，对于我们这种任务来说，`构建出来的 image 未免也大的过头了`，所以，就会采用这个多阶段构建的方式来压缩体积

### **Alpine 版本** (`Dockerfile.multistage`)

- **大小**: 33.1MB
- **适用场景**:
  - 需要调试工具的生产环境
  - 应用可能需要安装额外包
  - 需要 shell 访问

```dockerfile
# dockerfile.umltistage
# Build stage - 使用完整的 golang 镜像进行编译
FROM golang:1.25-alpine AS builder

# 安装必要的依赖（如果需要 CGO）
RUN apk add --no-cache git

# 设置工作目录
WORKDIR /usr/src/app

# 复制 go mod 文件并下载依赖
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY *.go ./

# 编译应用程序
# CGO_ENABLED=0 创建静态链接的二进制文件
# -ldflags="-w -s" 减小二进制文件大小
RUN CGO_ENABLED=0 GOOS=linux go build -a -ldflags="-w -s" -o app .

# Runtime stage - 使用最小的基础镜像
FROM alpine:latest

# 安装 CA 证书（如果应用需要 HTTPS 请求）
RUN apk --no-cache add ca-certificates

# 创建非 root 用户提高安全性
RUN adduser -D -s /bin/sh appuser

# 设置工作目录
WORKDIR /app

# 从 builder 阶段复制编译好的二进制文件
COPY --from=builder /usr/src/app/app .

# 更改文件所有者
RUN chown appuser:appuser /app/app

# 切换到非 root 用户
USER appuser

# 暴露端口
EXPOSE 8080

# 运行应用
CMD ["./app"]
```

```bash
# 构建 images 
docker build -t image_name_you_like -f Dockerfile.multis
```

> 📋 命令参数说明

- `docker build`: 构建 Docker 镜像的命令
- `-t go-app-multistage`: 为镜像指定标签名称
- `-f Dockerfile.multistage`: 指定使用的 Dockerfile 文件名（默认为 Dockerfile）
- `.`: 指定构建上下文为当前目录

### **Scratch 版本** (`Dockerfile.scratch`)

- **大小**: 9.62MB
- **适用场景**:
  - 纯粹的微服务
  - 最小攻击面要求
  - 资源极度受限的环境

<br>

## 网络

---

![image-20250802204825629](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250802204825629.png)

> [!warning]
>
> 如果我们某一次开机，某个容器的 IP 地址变动了的话，我们服务可能就出问题了，那请问，我们如何解决这个问题呢？
>
> - 我们可以制作一个自定义的网络，加入这个网络的容器可以通过`容器名`互相访问

| 命令                        | 说明                     | 文档地址                    |
| --------------------------- | ------------------------ | --------------------------- |
| `docker network create`     | 创建一个网络             | `docker network create`     |
| `docker network ls`         | 查看所有网络             | `docker network ls`         |
| `docker network rm`         | 删除指定网络             | `docker network rm`         |
| `docker network prune`      | 清除未使用的网络         | `docker network prune`      |
| `docker network connect`    | 使指定容器连接加入某网络 | `docker network connect`    |
| `docker network disconnect` | 使指定容器连接离开某网络 | `docker network disconnect` |
| `docker network inspect`    | 查看网络详细信息         | `docker network inspect`    |

<br>

## DockerCompose

---

> `DockerCompose`通过一个单独的`docker-compose.yml`模板文件（YAML格式）来定义一组相关联的应用容器，帮
> 助我们实现多个相互关联的Docker容器的快速部署。

![image-20250802220342782](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250802220342782.png)

> 比较命令 和 Compose 的差别

![image-20250802222351225](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250802222351225.png)

### docker-compose 命令

> - 如果你的 compose 文件不是 `docker-composer.yml` 而是你自定义的名字，那就 -f 指定
> - -d 是用于，我们 yaml 文件里面可能创建了不止一个配置，所以如果你想单独开启某一个，那就 -d <name>
>   - 这个 name 就是你 server 自己定义的那个
>   - <img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250821165519257.png" alt="image-20250821165519257" style="zoom:74%;" />

```shell
docker-compose -f <compose文件名> up -d <服务名>
```

### EMQX 

```yaml
services:
  emqx:
    image: emqx/emqx:latest
    container_name: emqx
    environment:
      - "EMQX_NAME=emqx"
      - "EMQX_HOST=localhost"          # 单节点，HOST 可以随意
      - "EMQX_ALLOW_ANONYMOUS=true"    # 可选：允许匿名连接
      - "EMQX_DASHBOARD__DEFAULT_USERNAME=admin"
      - "EMQX_DASHBOARD__DEFAULT_PASSWORD=123456"
    ports:
      - "1883:1883"
      - "8083:8083"
      - "8084:8084"
      - "8883:8883"
      - "18083:18083"
    networks:
      emqx-bridge:


# LINK - Explain the use of the port
# 1883 MQTT端口
# 8083 MQTT/WebSocket端口
# 8883 MQTT/SSL端口
# 8084 MQTT/WebSocket/SSL端口
# 18083 Dashboard 管理端口

networks:
  emqx-bridge:
    driver: bridge

```

```bash
docker logs -f emqx
```

> test

```bash
# 进入操作终端
docker exec -it emqx /bin/bash

# 查看节点状态
/opt/emqx/bin/emqx_ctl status

# 查看当前连接的客户端
/opt/emqx/bin/emqx_ctl clients list
```

<br>

### Mysql

```json
services:
  mysql:
    image: mysql:8.0
    container_name: mysql80
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD:-123456}
    ports:
      - "3306:3306"
    volumes:
      - ./mysql-data:/var/lib/mysql                # 数据持久化
      - ./init:/docker-entrypoint-initdb.d         # 可选：初始化 SQL 脚本
    command: [
      "--character-set-server=utf8mb4",
      "--collation-server=utf8mb4_unicode_ci",
      "--default-authentication-plugin=mysql_native_password"
    ]

networks:
  IOT_NETWORK:
    driver: bridge
```



<br>

# K8s

---

![image-20250807232027917](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250807232027917.png)

<br>