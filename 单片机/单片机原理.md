# 硬件相关知识

---

- [Type-C 尚硅谷视频介绍](https://www.bilibili.com/video/BV1AT421Y7DS/?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a&p=53)
- [编码器介绍](https://www.bilibili.com/video/BV1im42137c2/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)

<br>

## Type-C 3.0

---

### Type-C  的 Pin 以及对应的功能

> 因为这种对称的关系, 所以无论正反插其实都是可以的

![image-20250420154905743](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420154905743.png)

### 24-PIN 功能表

> 功能表
>
> **当然有些也用不上那么多功能, 所以有些其实 PIN 要少一些**

| 引脚        | 名称        | 功能简介                          | 备注                             |
| ----------- | ----------- | --------------------------------- | -------------------------------- |
| A1 / B1     | GND         | 接地                              | 电源负极                         |
| A4 / B4     | VBUS        | 电源正极                          | 通常 5V，也可能是 20V（PD 模式） |
| A5 / B5     | CC1 / CC2   | 配置通道（Configuration Channel） | 正反识别、角色检测、功率协商     |
| A6 / A7     | D+ / D−     | USB 2.0 数据线                    | 兼容老设备                       |
| B6 / B7     | D+ / D−     | USB 2.0 数据线                    | 正反插备用                       |
| **A2 / A3** | TX1+ / TX1− | USB 3.x TX 通道（发送）           | 超高速数据                       |
| B10/B11     | TX2+ / TX2− | USB 3.x TX 通道（发送）           | 反插时使用                       |
| A10/A11     | RX2+ / RX2− | USB 3.x RX 通道（接收）           | 反插时使用                       |
| B2 / B3     | RX1+ / RX1− | USB 3.x RX 通道（接收）           | 正插时使用                       |
| **A8 / B8** | SBU1 / SBU2 | Sideband Use 侧带信号             | 用于音频、视频（DisplayPort 等） |
| A9 / B9     | VCONN       | 给线缆内部芯片供电                | 通常通过 CC 反向脚供电           |



> 举例一个 16 PIN 的

![image-20250420155532603](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420155532603.png)

### 24-PIN VS 16-PIN

| 项目                     | 16PIN Type-C | 24PIN Type-C        |
| ------------------------ | ------------ | ------------------- |
| 引脚数量                 | 16（简化版） | 24（全功能）        |
| 支持 USB 2.0             | ✅ 是的       | ✅ 是的              |
| 支持 USB 3.x             | ❌ 不支持     | ✅ 是的              |
| 支持 PD 快充             | ✅ 可支持     | ✅ 可支持（更强）    |
| 支持视频输出（Alt Mode） | ❌ 不支持     | ✅ DisplayPort, HDMI |
| 支持 Thunderbolt         | ❌ 不支持     | ✅ 是的              |
| 成本                     | 💰 低         | 💰 高                |

### 4. 16-PIN 绘制

![image-20250420163503678](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420163503678.png)

### 实物图片

> 背面那个两排在焊接难度上有点大的

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420155218064.png" alt="image-20250420155218064" style="zoom:77%;" />

### Type-C 充电协议

> 你可以看到这个**输出其实是有多个结果**的, 这个是由快充芯片决定的
>
> 譬如说 USB 设备会通过改变USB端口的D+和D-电压组合向充电器发送信号，请求更高的充电电压
>
> 所以如果你没有充电芯片的设计的话, 其实最后拿到的供电就是 5V

![image-20250420164350551](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420164350551.png)

## 降压模块

---

### DCDC

- [DCDC 降压](https://www.bilibili.com/video/BV1644y1q74w/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)
- [DCDC 原理图实际绘制教学](https://www.bilibili.com/video/BV1xSzpYjEpd?spm_id_from=333.788.recommend_more_video.0&vd_source=b47817c1aa0db593f452034d53d4273a)

> 大致意思就是我们可以通过类似 PWM 那种方法, 用占空比实现降低电压, 譬如说这里的占空比是 1/2 所以电压就降成了一半
>

![image-20250422120705445](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422120705445.png)

### DCDC 硬件电路实现

> 虽然说降低了电压, 但是只是总额变低了, 他仍然不是一个稳定的值, 而是很多个矩形波
>
> 所以需要下面的电路实现一个整流

<div style="display: flex; justify-content: center;">
  <img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422120944020.png" alt="image-20250422120944020" style="zoom:65%;" />
</div>
- 电感是为了控制电流，让电流相对比较平缓
- 电容蓄能，防止开关变换的时候电压抖动过大
- 二极管的作用就是为了防止电感放电的时候出现反向导通

> 效果如下

![image-20250422121531861](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422121531861.png)

<br>

### DCDC 电路伏压平衡和电感计算

> [!note]
>
> 具体看看下面的文章，内容过多，在这里分析 
>
> - [DCDC 稳态分析](DCDC 稳态分析.md) 



<br>

### LDO

> [LDO 原理](https://www.bilibili.com/video/BV1t64y1b7w7/?spm_id_from=333.788.recommend_more_video.-1&vd_source=b47817c1aa0db593f452034d53d4273a)
>
> 实际就是通过分压实现的, 就比方说下面的分压电路

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422123529334.png" alt="image-20250422123529334" style="zoom:57%;" />

但是实际因为我们的电压变化的问题, 所以其实下面的负载电阻没那么稳定,所以我们希望上面的电阻能够智能一些, 根据下面的电阻阻值变化,调节自身的阻值

> 于是就有了下面的电路

### 4. LDO 硬件电路实现

> 具体思路就是通过这个比较器
>
> 看到最右侧的 5V 电压没有, 他会再一次进入到比较器, 和稳压二极管作比较, 通过比较来控制二极管对电压的放大或者变小, 以此来控制电压稳定在 5V

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422123704638.png" alt="image-20250422123704638" style="zoom:70%;" />

> 那么现在左侧的一大堆东西就是我们的智能电阻了, 稳定控制通过其的电压一定是 5V

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250422124441767.png" alt="image-20250422124441767" style="zoom:52%;" />

## MAX98357A

---

![image-20250701163806939](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701163806939.png)

 这个模块多个版本，有一个 `LRC`  然后这个是根据输入的高低电位判断当前数据`左还是右声道`

<br>

### 1. 声道的确定

> 内部框图

![image-20250701164944483](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701164944483.png)

> 注意这个绿色的部分，这个部分就是我们需要比较的电压

![image-20250701164854053](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250701164854053.png)

> 如果 SD 引脚悬空的话，默认是$\frac{L+R}{2}$

### 2. 增益的选择

| GAIN\_SLOT 接线方式       | I2S/LJ 增益 (dB) |
| ------------------------- | ---------------- |
| 通过 100kΩ ±5% 电阻接地   | 15               |
| 直接接地                  | 12               |
| 悬空                      | 9                |
| 接 VDD                    | 6                |
| 通过 100kΩ ±5% 电阻接 VDD | 3                |

<br>

## 编码器

---

### 1. 编码器的内部结构

> [!note]
>
> 所以我们的 `DT` 和 `CLK` 其实一直都是高电平，因这个上拉电阻的存在
>
> `SW` 是按下检测，默认接地，所以我们配置 GPIO 的时候，给 SW 上拉就好

![image-20250724113550613](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113550613.png)

### 电平如何突变

![image-20250724113843546](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113843546.png)

> 为此产生的对外波形其实是这样子的

![image-20250724113950073](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724113950073.png)

### 两个触电有周期相位的原理

> 就是因为这两个出点和拨片的接触时间永远都不会是同一时刻，所以会存在相位差。
>
> 正转和反转 同 触电 A B 相位前后的关系就显而易见了

![image-20250724114136697](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724114136697.png)

> - A 在前，正转
> - B 在前，反转

![image-20250724114405597](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724114405597.png)

<br>

## MPU6050

- [参考视频](https://www.bilibili.com/video/BV1ZhNHefEah/?vd_source=b47817c1aa0db593f452034d53d4273a)

![image-20251005162103211](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005162103211.png)

### 偏航角

![image-20251005161757858](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005161757858.png)

> [!warning]
>
> 为什么 y 是减是因为，我们的芯片摆放位置的是反的， roll 所在的位置是车体的车头，但是芯片所在位置是车尾，所以说不太一样

![image-20251005161830011](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005161830011.png)

### 加速度

![image-20251005164119754](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005164119754.png)

> 加速度只测算 pitch 和 roll，因为 Z 轴发生角度变换的时候，就是翻车了

![image-20251005163856680](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005163856680.png)

![image-20251005165920554](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251005165920554.png)

<br>

# 快充协议

---

> [!note]
>
> 只有 PD 和 QC 支持协议就可以达到快充，但是其他的数据线都必须是原厂的

## PD

![image-20251008123230635](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251008123230635.png)

## QC

![image-20251008123306320](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251008123306320.png)

## FCP/SCP

![image-20251008124003787](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251008124003787.png)

| 协议名                          | 全称                        | 所属厂商 / 阵营 | 简介                                                         |
| ------------------------------- | --------------------------- | --------------- | ------------------------------------------------------------ |
| **PD3.0 / PD (Power Delivery)** | USB Power Delivery          | USB-IF 官方标准 | 公有协议，USB 官方制定，电压最高可达 20V，支持双向供电（DRP, Try.SRC / Try.SNK） |
| **QC2.0 / QC3.0 / QC3.0+**      | Qualcomm Quick Charge       | 高通            | 安卓阵营早期主流快充协议，通过 D+/D− 电压通信协商提升电压（5V→9V→12V） |
| **SCP**                         | SuperCharge Protocol        | 华为            | 华为自研协议，电压较低（4.5V/5V/10V）但电流大（最大 5A），走自有通信机制 |
| **FCP**                         | Fast Charge Protocol        | 华为            | 华为旧版快充协议，支持 5V/9V/12V 等电压，与 SCP 共存，新机以 SCP 为主 |
| **AFC**                         | Adaptive Fast Charging      | 三星            | 基于 QC2.0 修改的私有协议，常见于三星 Galaxy 系列            |
| **DRP Try.SRC**                 | Dual Role Port (Try Source) | USB-IF 定义     | PD 的一部分，表示设备既能当电源（Source）又能当受电端（Sink），优先尝试当 Source |

<br>

## 协议是如何确定的（USB接口）

| 协议类型                 | 通信线路    | 握手方式             | 说明                              |
| ------------------------ | ----------- | -------------------- | --------------------------------- |
| **USB PD**               | **CC1/CC2** | 数字通信（BMC 编码） | 官方协议，通过 PD 控制器 MCU 通信 |
| **QC / AFC / FCP / SCP** | **D+ / D−** | 模拟电压信号         | 通过拉高或检测特定电压组合识别    |
| **普通 5V 充电**         | 无通信      | 默认 5V 输出         | 没检测到快充信号则降级为普通充电  |

<br>

# 编码

---

<br>

## WAV 编码

---

### 大小端问题

![image-20250405184910823](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405184910823.png)

> 图例解释
>
> 第一个图是我们的`x86计算机`保存的数据哈, 计算机是小端模式,所以重要的都在前面

![image-20250405184957458](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405184957458.png)

### WAV 文件头

> 所有的`WAV` = **44字节 头文件** + **PCM文件** 组成，这个文件头包含语音信号的所有参数信息（声道数、采样率、量化位数、比特率....）
>
> [特别细节的部分可以参考这个文章](https://www.cnblogs.com/LXP-Never/p/15234298.html#blogTitle4)

```c
typedef struct WAV_HEADER_S
{
    char            riffType[4]{'R','I','F','F'};    //4byte,资源交换文件标志:RIFF
    unsigned int    riffSize;                        //4byte,从下个地址到文件结尾的总字节数 = 文件总大小-8
    char            waveType[4]{'W','A','V','E'};    //4byte,wav文件标志:WAVE
    char            formatType[4]{'f','m','t',' '};  //4byte,波形文件标志:fmt(最后一位空格符)
    unsigned int    formatSize{16};                  //4byte,fmt chunk块的大小，不包含自己
    unsigned short  compressionCode{1};              //2byte,格式种类(1-线性pcm-WAVE_FORMAT_PCM,WAVEFORMAT_ADPCM)
    unsigned short  numChannels;                     //2byte,通道数
    unsigned int    sampleRate;                      //4byte,采样率
    unsigned int    bytesPerSecond;                  //4byte,每秒传输速率 = SampleRate * NumChannels * BitsPerSample/8
    unsigned short  blockAlign;                      //2byte,数据块的对齐，即DATA数据块长度 = NumChannels * BitsPerSample/8
    unsigned short  bitsPerSample;                   //2byte,采样精度-PCM位宽
    char            dataType[4]{'d','a','t','a'};    //4byte,数据标志:data
    unsigned int    dataSize;                        //4byte,从下个地址到文件结尾的总字节数。即除了wav header 以外的 pcm data length = 文件大小 - 44
} WAV_HEADER;
```

![](https://upload.wikimedia.org/wikipedia/commons/8/8c/Wave_format.png)

### 1.3 PCM 数据的排列

> 第三个排序是最好的,正好和计算机和ESP一样都是小端序

![image-20250405185913414](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250405185913414.png)

### 1.4 制作音频需要的计算

```cpp
FsFile file;  // 定义一个文件对象，用于录音文件操作

const int record_time = 60;  // 定义录音时长（单位：秒）
const char filename[] = "/我的录音.wav";  // 定义录音文件名

// 计算音频数据大小（假设采样率为44100Hz，16位位宽，单声道）
const int waveDataSize = record_time * 88200;  // 88200 = 44100 * (16 / 8 == 2 Byte) * 1（单声道）

// 打开或创建文件
file = sd.open(filename, O_WRITE | O_CREAT);
if (!file) {	
    Serial.println("crate file error");  // 如果文件打开失败，输出错误信息
    return;  // 返回，结束操作
}

// 创建WAV文件头（假设有一个函数CreateWaveHeader用于生成WAV头）
auto header = CreateWaveHeader(1, 44100, 16);  // 参数：通道数、采样率、位宽

// 更新 WAV文件头 中的文件大小字段
header.riffSize = waveDataSize + 44 - 8;  // riffSize = 数据大小 + 44（文件头大小） - 8（RIFF和WAVE部分）
header.dataSize = waveDataSize;  // 更新数据块的大小

// 将WAV文件头写入文件
file.write(&header, 44);  // 写入44字节的文件头
```

<br>

## 电机编码

---

### 编码器的模式

> [!note]
>
> 在 `HAL` 库里面的硬件逻辑：

![image-20250724115512881](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724115512881.png)

- 模式1：在A相的边沿计数(Counting On Tl1 Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122155256.png" alt="image-20250724122155256" style="zoom:50%;" />

- 模式2：在B相的边沿计数(Counting On Tl2 Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122249244.png" alt="image-20250724122249244" style="zoom:50%;" />

- 模式3：双边沿计数(Counting On Both Edge)

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122303818.png" alt="image-20250724122303818" style="zoom:50%;" />

> [!important]
>
> 记住，不论是那种模式，采样的时候，我们都是下面的原则计数：

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724124737086.png" alt="image-20250724124737086" style="zoom:67%;" />

### 2. HAL 操作

> [!note]
>
> 接线情况，好像 RX 和 TX 接线有点问题，要注意下

![image-20250724122531946](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122531946.png)

> `CUBEMX UI` 配置

![image-20250724122839351](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724122839351.png)

> 编码器部分，我们这样子设置，采用模式 1，然后启用`上升沿捕获`
>
> 如果采用了`下降沿捕获`的话，顺时针是减哦，因为这个时候，因为 A 下降沿的时候，B 是在前面的，采样的时候，就认为是 B 在前，`CNT --`

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250724124259685.png" alt="image-20250724124259685" style="zoom:50%;" />

<br>

# 通信

---

- [红外通信介绍](https://www.bilibili.com/video/BV1z8411g7jn/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)
- [MQTT 协议详细介绍](https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html)
- [使用 docker 创建一个 MQTT 服务器](https://mp.weixin.qq.com/s/qYH78Am12sZI5cm2aDYn6Q)
- [蓝牙协议 - 尚硅谷](https://www.bilibili.com/video/BV1RVR3YNEkN?spm_id_from=333.788.player.switch&vd_source=b47817c1aa0db593f452034d53d4273a&p=5)

## 常见的通信和性质

![image-20250114113118335](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114113118335.png)

### 时钟

- **异步通信（Asynchronous）**：通信双方不依赖共享时钟信号，而是通过约定的**波特率（baud rate）**进行数据传输。数据的开始和结束由特定的起始和停止位标识

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122104776.png" alt="s" style="zoom:74%;" />

- **同步通信（Synchronous）**：发送和接收端共享一个时钟信号，通过时钟同步实现数据传输

![image-20250114122036666](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122036666.png)

### 双工

- **全双工**：两个线之间同时可以互相发送数据

![image-20250114113928109](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114113928109.png)

- **半双工**：发送和接受是同一个线，所以不可以同时满足两个功能，就是这种数据一发一回应的模式，所以才有这种 **主从模式**

![image-20250114114043417](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114114043417.png)



### 电平

- **单端通信**：数据通过一个信号线和一个公共地线传输。常见的 RS-232 串口通信属于单端通信。
- **差分通信**：数据通过两根电平互补的信号线传输，例如 RS-485 接口，抗干扰能力更强。

<br>

### 设备

- **点对点通信**：两个设备直接进行通信，双方之间不存在其他中介设备。USART 通信通常是点对点的，如电脑和 STM32 之间的串口通信
- **多设备通信**：指在一个通信网络中，多个设备相互传递数据的通信模式。多设备通信通常包括多方参与，可以是点对多点、广播或点到点的组合

<br>

## USRT 通信

---

### USRT 的性质

> 交叉这一点非常的重要，我们 STM 32 的串口和 COM3 的端口要注意交叉

![image-20250104183706554](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104183706554.png)

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104123126284.png" alt="image-20250104123126284" style="zoom:70%;" />

### 2. 电平标准

> 电平标准是数据`1`和数据`0`的表达方式

- TTL电平：`+3.3V`或`+5V`表示 1，`0V` 表示 0

- RS232电平：`-3~-15V`表示 1，`+3~+15V`表示 0

- RS485电平：两线压差`+2~+6V`表示 1，`-6~-2V`表示 0（差分信号）

### $\textcolor{pink}{3. 串口参数和时序}$

![image-20250104124042931](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250104124042931.png)

> 波特率：每隔多少时间发送一个电平
>
> - 波特率换时间就是：$\frac{1}{波特率} \times 10^6 \mu s$
> - $波特率 = \frac{f_{PCLK2/1}}{16 \times DIV}$
>
> 起始位：一开始是啥电平，一般是低电平，因为我们一开始是一直是高电平，然后我们转低电平告诉我们数据开始传输了
>
> 数据位：譬如说我要发送，`0x0F -> 0000 1111`，因为**低位先行**所以发送的数据其实是：`1111 0000`，虽然说发送的是反过来的，但是接受的 RX 是接受然后右移，所以最后接受的数据会再翻转一次，结果仍然是正的
>
> 校验码：[参考这个视频](https://www.bilibili.com/video/BV1HbSBYGEAQ/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)，因为我们采用的实际上是 奇偶效验，更好的方法可以参考 CRC 校验

<br>

## I2C 通信

---

### I2C 的性质

> - I2C（Inter IC Bus）是由`Philips` 公司开发的一种通用数据总线
> - 两根通信线：SCL（Serial Clock）、SDA（Serial Data）
> - 带数据应答
> - 支持总线挂载多设备（**一主多从**、多主多从），我们主要学习第一种模式

![image-20250114120856778](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114120856778.png)

<br>

### 一主多从模式

> - 设备的SCL和SDA均要配置成**开漏输出模式**
>
> - SCL和SDA各添加一个**上拉电阻**，阻值一般为4.7KΩ左右
>
> - 所以如果是软件模拟，默认是上拉，设置成开漏（不让他具有自己下拉的能力，让外部提供高电平）

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114121136522.png" alt="image-20250114121136522" style="zoom:67%;" />

> [!caution]
>
> 必须要设置成为`开漏`，不然多个受控的设备如果有的拉高有的拉低，形成了回路就直接烧了

![image-20250713215545517](C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20250713215545517.png)

> [!note]
>
> 第三个<span style="background:#990000;">红框</span>的参数是设置传输速率，一般有两种
>
> - 标准100kbps
> - 快速400kbps

<br>

### 基本时序

---

#### 开始和停止条件

- **起始条件**：SCL**高电平**期间，SDA从高电平切换到低电平

![image-20250114122440066](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114122440066.png)

- **终止条件**：SCL**高电平**期间，SDA从低电平切换到高电平

![image-20251022125316134](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022125316134.png)

#### 发送一个字节

> **从机**SCL**低电平**期间，**主机**将数据位依次放到SDA线上（高位先行），然后释放SCL，**从机将在SCL高电平期间读取数据位**，*所以SCL高电平期间SDA不允许有数据变化*，依次循环上述过程8次，即可发送一个字节
>
> SCL 是一个垂直运输机，SDA 就是这个运输机上的东西，一开始就是被放下来准备接东西（低电平），上升去之后（就变成高电平了），就把东西给给运走了。然后还没有放下来运下一次的东西之前，我们不允许放下一次的东西。
>
> 我们的东西排布一开始是 0 1 2 3 4 5 6 7 8，但是接受的肯定是先拿到 0，所以他们哪里的排序就是 8 7 6 5 4 3 2 1 0，也就是所谓的**高位先行**

![image-20250114123754375](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114123754375.png)

- SDA 在 SCL 低电平发生了变化，于是 SCL 拉高，然后读取 SDA 电平

<br>

#### 接受一个字节

> SCL 低电平期间，**从机**将数据位依次放到SDA线上（`高位先行`），然后释放SCL，主机将在SCL**高电平期间读取**数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）

![image-20251022131014902](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022131014902.png)

> 高位先行

![image-20251022132336012](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022132336012.png)

<br>

#### ACK

> 反正就是接收方反应状态

| 操作           | 数据方向    | 谁发送 ACK/NACK   | 说明                                     |
| -------------- | ----------- | ----------------- | ---------------------------------------- |
| 地址帧         | 主机 → 从机 | 从机发送 ACK      | 地址匹配则从机响应，否则 NACK            |
| 数据帧（写入） | 主机 → 从机 | 从机发送 ACK      | 从机接收数据成功，否则 NACK              |
| 数据帧（读取） | 从机 → 主机 | 主机发送 ACK/NACK | 主机需要更多数据发送 ACK，结束时发送 NAC |

![image-20250114131351181](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114131351181.png)

<br>

### 一帧完整的数据

---

#### 写数据帧

> **R/W 标志位**：写操作为 `0`
>
> **应答位 1 （ACK）**：
>
> - 从机接收到地址帧后，如果识别出自己的地址，会拉低 SDA，表示 ACK（应答）
> - 如果没有从机响应，则 SDA 保持高电平，表示 NACK
>
> **应答位 2（ACK/NACK）**：
>
> - 从机接收数据后，若接收成功，会返回 ACK。
> - 如果接收失败或从机不准备继续通信，会返回 NACK。

![image-2025011413160+5578](https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250114131605578.png)

- 简化表示

```scss
// ... 表示重复的 | Data (8 bits) | ACK |
| Start | Address (7/10 bits) + Write(0) | ACK | Data (8 bits) | ACK | ... | Stop |
```

![image-20250713233800925](C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20250713233800925.png)

<br>

#### 读数据帧

> **应答位 1（ACK）**：
>
> - 从机识别出地址后，会拉低 SDA，表示 ACK。
>
> **应答位 2（ACK/NACK）**：
>
> - 主机接收到数据后，若需要继续接收数据，会发送 ACK。
> - 若不需要继续接收数据，则发送 NACK。

```scss
| Start | Address (7/10 bits) + Read(1) | ACK | Data (8 bits) | ACK/NACK | ... | Stop |
```

- 设备地址是厂商给我们的，所以可以查手册找到，然后我们的地址一般都是 7 位，所以一共有 $2^7 -1$ 那么多个
- 当然如果不同硬件的设备地址重复了，也可以自己修改，可以通过电路硬件改变低位，实现改变数据

<br>

#### 复合数据帧

> 对当前地址读
>
> 对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）

![image-20251022130309327](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022130309327.png)

> 对指定地址读
>
> 对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）

> 指定地址写
>
> 对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）

![image-20251022131409622](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022131409622.png)

![image-20251022130722575](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022130722575.png)

<br>

## SPI 通信

> - SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线
> - 四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）
> - 同步，全双工
> - 支持总线挂载多设备（一主多从）

<br>

### 硬件电路

> 因为是全双工，所以和 SDA 不太一样，有两个线来接受输入和输出，而且选择从机也不再想 I2C 一样发送地址到从机看有无应答，而是直接使用 SS 线去找从机，相当于一个从机设备一根单独的线，给对应的 SS 高电平就是去找对应的从机
>
> **输出引脚**配置为**推挽输出（PP）**，输入引脚配置为浮空或**上拉输入**，所以电路高电平驱动很强，上升速度快
>
> **MOSI (主设备输出数据)** 连接到 **DI (设备数据输入)**。
>
> **MISO (主设备接收数据)** 连接到 **DO (设备数据输出)**。

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250119103908324.png" alt="image-20250119103908324" style="zoom:67%;" />

### SPI 移位示意图

> SPI（串行外设接口）通信中的数据传输过程是基于移位寄存器的，它通过时钟信号（SCK）同步传输数据
>
> 高电平的时候输出数据，低电平的时候读取数据，两个数据的轮流的读取写入，实现了数据的交换，所以 SPI 的数据就是这么一个数据交换的过程，**也就实现了发送的时候同时接受**
>
> 如果我们只想发送，那就不管接受的数据就好，如果我们只想接受，那就发送 `0x00` 等没用数据就行，所以有点浪费，因为i我们在做单独的 I/O 的时候，其实不需要两个线的资源都使用，没必要交换数据

<img src="https://cdn.jsdelivr.net/gh/MTsocute/New_Image@main/img/image-20250119104938946.png" alt="image-20250119104938946" style="zoom:67%;" />

> 效果演示

<img src="https://i-blog.csdnimg.cn/blog_migrate/08aeef78767d385476a91f849b155617.gif" alt="img" style="zoom:67%;" />

### SPI 时序

---

#### 起始和终止条件

> 相对于 $I^2C$ 确实简单许多，不需要 SDA 和 SCL 同时配合了
>
> 左边是开始，右边是终止

![image-20251022133218952](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022133218952.png)

#### 交换一个字节（模式 0）

> SCK 第一个边沿移入数据，第二个边沿移出数据

![image-20251022133813863](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251022133813863.png)

> 这里写 B7 是因为 Cortex-M3 是小端序存储，低地址存储低字节；高地址存储高字节
>
> 所以 B7 存储的是起始字节

<br>

## NEC 红外通信协议

---

### NEC 协议的特点

> #### （1）8位地址和8位命令长度
>
> - NEC协议使用**8位地址码和8位命令码**。
>
> #### （2）扩展模式可用，加倍地址大小
>
> - NEC协议有一个扩展模式，可以将地址长度从8位扩展到16位，从而提供更多的地址空间，允许更多的设备被唯一标识。
>
> #### （3）地址和命令都传输两次以提高可靠性
>
> - 为了确保数据的可靠性，NEC协议会将地址和命令各发送两次。第一次发送原始值，第二次发送其反码（inverted code）。
>
> #### （5）载波频率为38kHz
>
> - 红外信号的载波频率为38kHz，这是红外通信中常用的频率，可以确保信号的传输效率和抗干扰能力。
> - 这个载波可以通过 PWM 那种间歇性闪烁的效果, 虽然不会改变强度, 但是这个就区分了自然光红外和我们的红外  
> - ![image-20250323121130267](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323121130267.png)
> - ![image-20250323121155124](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323121155124.png)
>
> #### （6）位时间是1.125ms或2.25ms
>
> - 在NEC协议中，每个位的持续时间可以是1.125ms或2.25ms，这取决于位的值。逻辑"0"通常用一个较短的脉冲表示，而逻辑"1"用一个较长的脉冲表示。这种编码方式有助于接收器区分`逻辑"0"`和`逻辑"1"`
> - 仔细看高电平的部分,不是平的,而是38kHz载波的夹杂效果
>
> ![img](https://i-blog.csdnimg.cn/direct/26ba4ece8bfe48e5875ca3b8f5935a2e.png)
>
> #### （7） 完整的数据传输格式
>
> - 引导码+8位地址码+8位地址反码+8位命令码+8位命令反码。

### NEC 协议

> 如图展示了NEC协议的一个典型脉冲序列。
>
> 根据这个协议，**最低位（LSB）首先被传输**。在这个例子中，地址 0x59 和 命令 0x16 被传输。

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250323180005702.png" alt="image-20250323180005702" style="zoom:70%;" />

消息的开始是一个9ms的AGC脉冲，这个脉冲被用来设置早期红外接收器的增益。这个AGC脉冲之后是一个4.5ms的间隙，紧接着是地址和命令的传输。

地址和命令各传输两次，第二次所有位都取反，可以用于验证接收到的消息。由于每个位都以其取反的长度重复，因此总的传输时间是固定的。如果你不关心这种可靠性，可以忽略取反的值，或者你可以将地址和命令各扩展到16位！ **请注意，在消息的末尾必须跟随一个额外的560µs脉冲，以便能够确定最后一个位的值**

```c
// 发送NEC数据位 0/1
void IR_SendBit(uint8_t bit) {
    if (bit) {                       //数据位1
        TIM_SetCompare3(TIM3, 9);    // 产生560us的高电平
        Delay_us(560);
        TIM_SetCompare3(TIM3, 0);    // 产生1680us的低电平
        Delay_us(1680);
    } else {                         //数据位0
        TIM_SetCompare3(TIM3, 9);    // 产生560us的高电平
        Delay_us(560);
        TIM_SetCompare3(TIM3, 0);    // 产生560us的低电平
        Delay_us(560);
    }
}
```

<br>

## I2S

---

> I2S (`Inter-IC Sound`) 专门为音频而开发的一个通讯协议,
>

![img](https://pic3.zhimg.com/v2-d5d820543ba725cf355548fe5a405852_1440w.jpg)

### 信号线

> - `时钟线（Continues Serial Clock，SCK）`：SCK线提供了同步音频数据传输的时钟信号。确定了数据传输的速度和时序。该时钟也称为[Bit Clock](https://zhida.zhihu.com/search?content_id=239006157&content_type=Article&match_order=1&q=Bit+Clock&zhida_source=entity)（BCLK）。`SCK的频率=2x采样频率x位宽`
> - `左/右声道线（Left-Right Clock，LRCK, WS）`：LRCK线指示了当前传输的是左声道的音频数据还是右声道的音频数据。它被称为[帧同步信号](https://zhida.zhihu.com/search?content_id=239006157&content_type=Article&match_order=1&q=帧同步信号&zhida_source=entity)。`LRCK的频率=采样频率`
> - `数据线（Serial Data，SD）`：SD线用于传输实际的音频数据。数据的位宽可以根据具体应用而变化，通常为16位或32位。TX方向为：Serial Data Out（SDOUT）；RX方向为：Serial Data In（SDIN）。

> [!important]
>
> 注意看自己的开发板 `I2S` 有啥能力

![image-20250702104628187](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250702104628187.png)

<br>

### 数据传输模式

> **Philips 格式**：数据信号与 WS 信号相比有一个位的位移。WS 信号的占空比为 50%。

![img](https://picx.zhimg.com/v2-fae309fbced394f8ae6fe3ec82c95a4d_1440w.jpg)

> 1. **LRCK（左右声道选择信号）**：LRCK信号用于指示当前数据帧是左声道数据还是右声道数据。当LRCK为低时，表示当前传输的数据是左声道数据；当LRCK为高时，表示当前传输的数据为右声道数据, **LRCK 在一次完整的数据传输周期的中间会翻转（0→1 或 1→0）** --> WS
>
> 2. **SCK（位时钟）**：数据传输的时钟信号。$\textcolor{pink}{在SCK下降沿发送数据，在SCK上升沿采样数据}$
>
> 3. **Data Delay (数据延迟)**：`LRCK` 变化后，数据传输会**延迟 1 个 SCK 周期**
>
> 4. **MSB (Most Significant Bit)**:  高位数据先发, 且与`LRCK` 差 1 个`SCK`

> **PCM 帧同步**：数据有一个位的位移，同时 WS 信号变成脉冲，持续一个 BCLK 周期。

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/wavedrom.svg" alt="wavedrom" style="zoom:125%;" />

<br>

### 数据位宽与位深

---

#### 位宽

> **位宽**: **数据位宽**通常指的是 **I2S 传输的数据总长度**，也就是 **每个声道传输的比特数**

- 数据位宽决定了 I2S 传输时**每个声道所占的时钟周期数**。

```yaml
# 示例（32-bit 位宽，16-bit 数据），因为采样是左右声道，哪怕有一个没有，位宽也是那么多
PCM 数据： 1011 0011 1101 0101 | 0000 0000 0000 0000
                        ↑                 ↑
                   16-bit 数据         16-bit 填充位
```

<br>

#### 位深

> **位深**: **位深**指的是**音频数据本身的精度**，也就是**每个采样点用多少位来表示音频信号**
>
> 位深与信噪比（SNR）相关：

$$
SNR(dB) = 6.02 \times Bit\text{ }Depth + 1.76
$$

- 位深越高，音频的**动态范围**越大，即最小和最大音量的差距，能表示的声音细节就越多

```markdown
> 16-bit：动态范围 ≈ 96 dB（6.02×16+1.76=96.08）
> 24-bit：动态范围 ≈ 144 dB
> 32-bit：动态范围 ≈ 192 dB（但一般人耳听不出这么细的差别）
```

<br>

#### 总结

> 位深是夹在位宽中发送的数据

| 概念         | 作用                 | 计算方式                              | 影响                    |
| ------------ | -------------------- | ------------------------------------- | ----------------------- |
| **数据位宽** | I2S 数据传输最大长度 | 由 I2S 硬件决定                       | 影响数据的 SCK 传输效率 |
| **位深**     | 音频数据的有效位数   | $2^{\text{Bit Depth}}$ 表示的振幅级数 | 影响音频质量            |

<br>

## MQTT 协议

---



<img src="https://www.twilio.com/content/dam/twilio-com/global/en/blog/legacy/2023/what-is-mqtt/MQTT_Diagram_gOmDdU4.png" style="zoom:28%;" />

![02packetformat.png](https://assets.emqx.com/images/e67b987e03842cb19ca7608b14977f36.png?x-image-process=image/resize,w_1520/format,webp)

<br>

## Bluetooth 协议

---

> 新时代的蓝牙都不是为了速度而来的, 而是低功耗, 所以都是 `BLE` 为主流

![image-20250420181150781](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250420181150781.png)

## USB 协议

---

- [参考视频](https://www.bilibili.com/video/BV1ArvTzwEse/?spm_id_from=333.337.search-card.all.click&vd_source=b47817c1aa0db593f452034d53d4273a)
- [参考知乎文章](https://zhuanlan.zhihu.com/p/683251257)

### NRZI

> **NRZI编码 ( `Non-Return to Zero Inverted, 非归零反向编码`)**是将我们要发送数字信号 ，只有在 0 的时候发生点评切换，1 时不变

![image-20251003060057288](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003060057288.png)

### 设备通讯

> 我们通讯的设备会在其 D+/D- 上面接上拉电阻，接 D+ 表示高速，接 D- 表示低速。虽然大部分的设备都是高速。低俗还是有的，譬如键盘，估计因为手敲烂了，也达不到人家的速度传输速率

<img src="https://pica.zhimg.com/v2-2c10cb1adc2c725e9f3ecfae2bd9be36_1440w.jpg" alt="img" style="zoom:67%;" />

<br>

#### 通讯的建立

> 设备插入的时候，被拉高的数据线拉低一段时间，然后给接入的设备地址`0 用这个临时地址`通讯
>
> 主机主动轮询询问设备机的作用，然后设备发送`设备描述符、配置描述符`，告知自己的作用、厂家之类的相关信息

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003061623333.png" alt="image-20251003061623333" style="zoom:67%;" />

#### 设备描述符

> 里面主要包括这些内容
>

<img src="https://pic4.zhimg.com/v2-6ae39017b060c0479025306db7b3b421_r.jpg" alt="img" style="zoom:80%;" />

>
> 其中厂商 ID 是具有全球唯一性的

![image-20251003062729236](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003062729236.png)

#### 配置描述符

> 发送数据描述符之后，主机给从机发送地址，标定其为 `1 ~ 127` 区间内中的一个
>
> 然后从机通过这个地址，发送自己的配置描述符，一般 9 个字节，之后就开始正常通讯了

![img](https://picx.zhimg.com/v2-7c07a5adbdea1094ca3abdcc94410943_1440w.jpg)



### 通讯传输方式

> 这里具体看视频，重在了解通讯的机制和方式，不需要过多的深究

#### 中断传输

> 键盘和鼠标就是，主从采用轮询制度，然后间隔一段时间从从机读取数据，时间间隔大致为：`全速是1ms，高速则是0.125ms`

#### BULK传输

> BULK 传输多用于大容量存储(U盘) ， 传输速率受`系统占用率`影响单片机原理
>
> ESP32

![image-20251003070400934](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003070400934.png)

<br>

### USB 协议构成

> USB协议类似套娃，`最小单位为包` ，不同包的组合形成事务 ， 不同的事务组合形成传输 ， USB不同的类会指定某种传输模式

![img](https://pica.zhimg.com/v2-641ee566541ef29563929cdd40f1d896_1440w.jpg)

### 包

---

#### 包的构成

![img](https://pic4.zhimg.com/v2-e0d77d5a8f638f6d7ffa2e63adba894b_1440w.jpg)

- SOP ： (start of packet) 包的起始信号 ，是一种特殊的电平信号 ，`类似I2c的start信号`
- SYNC： 同步信号 ，用于消除通信过程中的相位误差
- EOP：包的结束信号，`类似 I2C的 stop信号`
- `Packet content`
  - PID ：包的标识符 ，通过此字段标识包的类型 ： 令牌包 ， 数据包 ，握手包 ，特殊包
  - ADDRRESS : 7bits 的设备地址 (一个host最多连接127个device) , 4bits的端点地址 (最多支持16个端点)
  - Frame number: 帧号 ，只在特定的包里面存在
  - data : 数据域 ， 最大1024字节 ，可为0字节。
  - CRC ： 包内容CRC校验



#### 包的分类

<img src="https://pic4.zhimg.com/v2-7fd86d6feab333650cf678baf5df58ad_1440w.jpg" alt="img" style="zoom:80%;" />

#### 令牌包

> 总体来看是这种感觉，这个包是`令牌包`，具体看下

![image-20251003064155668](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003064155668.png)

##### PID

> 令牌包是  8 位，前面四位就是有效位，然后后面就是前面的取反，组成了 8 位

<img src="https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003064544627.png" alt="image-20251003064544627" style="zoom:67%;" />

##### 地址

> 七位地址就是 0~127 的二进制格式，就是设备的地址

#### 数据包

> 令牌包一般是`主机主动和从机通讯，所以需要带地址`，但是`数据包就不用了`，直接`地址用于 CRC 校验`去了
>
> 其中数据的部分是 `0~1024` 范围内的数据大小，这个取决于设备传输使用了高速、低速、全速

![image-20251003065600101](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20251003065600101.png)

#### 握手包

![image-20251003065743141](C:\Users\shuhe\AppData\Roaming\Typora\typora-user-images\image-20251003065743141.png)

<br>

# Ex. 计组

---

## 寻址大小的计算

> 给定你一个模块的寻址地址大小是 $24 \text{ }bit$，所以你就可以知道我们的寻址能力就是 $\frac{2^{24}}{2^{20}} = 16 \text{} MB$

假设你的单片机是 **16 位的**，它只能支持 **16 位地址总线**。这意味着它最多能寻址 2^16 = 65,536 个位置，也就是 **64KB 的存储空间**。

如果你连接的是一个 32MB 的闪存芯片（如 W25Q256），它的寻址范围从 0x000000 到 0x1FFFFFFF。由于你的单片机只有 16 位的寻址能力，**它将无法直接访问超过 64KB 的存储空间**，因此它无法访问到 W25Q256 的大部分存储空间。

<br>

## 计算机组成

![image-20250421175622630](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250421175622630.png)

